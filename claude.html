<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeless: The Infinite Calendar</title>
    <style>
:root {
--border-width: 1px;
--border-color: black;
--header-height: 27px;
--shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* Reset / Base */
html, body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
               "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans",
               "Helvetica Neue", Arial, sans-serif;
  background: white;
  color: black;
}

/* Fixed Header at the Top */
#header {
  line-height: var(--header-height);
  background: white;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: var(--header-height);
  padding: 5px;
  text-align: center;
  border-bottom: var(--border-width) solid var(--border-color);
  z-index: 999;
  padding-bottom: 80px;
}

/* Timeless Title Button */
a.timeless {
  font-size: 137%;
  text-decoration: none;
  background: linear-gradient(to bottom, #E0E0E0, #CFE7FF);
  box-shadow: var(--shadow);
  color: #000;
  padding: 3px 10px;
  border-radius: 4px;
  display: inline-block;
  transition: background 0.3s, box-shadow 0.3s, transform 0.3s;
  margin-top: 10px;
  margin-bottom: 10px;
}
a.timeless:hover {
  background: linear-gradient(to bottom, #D0D0FF, #B0C0E7);
}
a.timeless:active {
  color: #FFF;
  background: linear-gradient(to bottom, #909090, #707070);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  transform: translateY(2px);
}

/* Help Overlay */
#help {
  display: none;
  position: fixed;
  left: 0; right: 0;
  bottom: 0; top: 0;
  background: rgba(0, 0, 0, 0.75);
  z-index: 2000;
}

#help div {
  text-align: right;
  margin: 150px auto;
  width: 400px;
  height: 90px;
  padding: 20px;
  color: black;
  border-radius: 10px;
  box-shadow: var(--shadow);
  background: white;
}

#help ul {
  margin: 0;
  padding: 0 0 20px 20px;
  text-align: left;
  line-height: 15px;
}

/* Buttons */
a.button {
  font-size: 200%;
  display: inline-block;
  color: black;
  text-decoration: none;
  padding: 13px;
  line-height: 15px;
  margin-left: 5px;
  border: 1px solid #999;
  border-radius: 4px;
  background: linear-gradient(to bottom, #FFFFFF, #DFDFDF);
  transition: all 0.3s;
  position: relative;
}

a.button:hover {
  background: linear-gradient(to bottom, #E0E0E0, #C0C0C0);
  box-shadow: var(--shadow);
  z-index: 1001;
}

a.button:active {
  background: linear-gradient(to bottom, #B0B0B0, #909090);
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
  transform: translateY(1px);
}

.button::after {
  content: attr(data-tooltip);
  position: absolute;
  top: 50%;
  right: 105%;
  transform: translateY(-50%);
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 1000;
}

.button:hover::after {
  opacity: 1;
  transform: translateY(-50%) translateX(-5px);
}

/* The Calendar Table */
table {
  width: 960px;
  margin: 0 auto;
  table-layout: fixed;
  border-spacing: 0;
  border-left: 1px solid black;
  border-top: 1px solid black;
}

td {
  border-right: 1px solid black;
  border-bottom: 1px solid black;
  padding: 3px 15px 20px 3px;
  text-align: right;
  vertical-align: top;
  width: 120px;
  height: 100px;
  cursor: pointer;
  box-sizing: border-box;
  width: 120px;
  word-wrap: break-word;
  white-space: normal;
  overflow: hidden;
  text-overflow: ellipsis;
}

td.extra {
  width: 120px;
  padding: 3px 10px;
  text-align: left;
  border: none;
  font: bold 30px 'Arial Narrow', sans-serif;
  line-height: 33px;
  cursor: auto;
}

td.shaded {
  background: #CFE7FF;
}

td.weekend {
  background-color: #f0f7ff;
}

td.today {
  background-color: #C92228;
  border: var(--border-width) solid #C92228;
  color: #FFF;
  font-weight: bold;
  font-size: 150%;
  text-transform: uppercase;
  box-shadow: var(--shadow);
  text-align: center;
}

textarea {
  display: block;
  width: 100%;
  overflow: hidden;
  font: 12px sans-serif;
  margin: 3px 0 0 0;
  padding: 2px 5px 0 5px;
  background: #CFE7FF;
  border: 1px solid #5FAFFF;
  border-radius: 4px;
  resize: none;
  box-sizing: border-box;
}

textarea:focus {
  outline: none;
}

td.shaded textarea {
  background: white;
}

/* Fix for main calendar container */
#calendarContainer {
  margin-top: 120px; /* Give space for the fixed header */
}

/* File input styling */
#fileInput {
  display: none;
}
    </style>
</head>
<body>
    <div id="header">
        <a href="/" class="timeless">Timeless</a>
        <span>ü™ê</span>
        <div>
            <span>Timeless: The Infinite Calendar ‚ú®</span>
            <a href="#" class="button" onclick="downloadLocalStorageData()" data-tooltip="Download Calendar Data">üì•</a>
            <a href="#" class="button" onclick="document.getElementById('fileInput').click()" data-tooltip="Load Calendar Data">üíæ</a>
            <a href="#" class="button" onclick="smoothScrollToToday()" data-tooltip="Scroll to Today">üìÖ</a>
            <a href="#" class="button" onclick="shouldLoadOrExport()" data-tooltip="Sync with Cloud">üîÑ</a>
            <a href="#" class="button" onclick="showHelp()" data-tooltip="Help">‚ÑπÔ∏è</a>
            <input type="file" id="fileInput" onchange="loadDataFromFile()">
            <span>Jump to date:</span>
            <input type="date" id="jumpDate">
            <button onclick="jumpToDate()">Go</button>
            <button onclick="undoLastChange()">Undo</button>
        </div>
    </div>

    <div id="help">
        <div>
            <ul>
                <li>Click on a day to add a note</li>
                <li>To delete a note, just delete its text</li>
                <li>Scroll to travel forward/backward in time</li>
            </ul>
            <a href="#" onclick="hideHelp()">Close</a>
        </div>
    </div>

    <div id="calendarContainer">
        <table id="calendar"></table>
    </div>

    <script>
/*
 * Timeless: The Infinitely Scrolling Calendar
 * by Jay Dixit
 *
 * An appreciative fork of Continuous Calendar by Evan Wallace
 */

// The real system date, which we do not overwrite during normal usage
let systemToday = new Date();

// The user-chosen or current "focus" date for the calendar
let todayDate;

// GLOBAL UNDO STACK
let undoStack = [];
const MAX_UNDO = 5;

function pushUndoState() {
  const snapshot = {};
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      snapshot[key] = localStorage[key];
    }
  }
  undoStack.push(JSON.stringify(snapshot));
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
}

function undoLastChange() {
  if (undoStack.length === 0) {
    alert("No undo history available.");
    return;
  }
  const lastSnapshotStr = undoStack.pop();
  if (!lastSnapshotStr) return;

  // Restore localStorage
  localStorage.clear();
  const snapshotData = JSON.parse(lastSnapshotStr);
  for (const key in snapshotData) {
    localStorage.setItem(key, snapshotData[key]);
  }
  location.reload();
}

// KEYBOARD NAVIGATION
document.addEventListener("keydown", (e) => {
  // Don't override arrow keys if typing in a note
  if (e.target && e.target.tagName.toLowerCase() === "textarea") return;

  if (e.key === "ArrowUp") {
    window.scrollBy(0, -window.innerHeight / 2);
  } else if (e.key === "ArrowDown") {
    window.scrollBy(0, window.innerHeight / 2);
  } else if (e.key === "t" || e.key === "T") {
    // Revert to real system date
    todayDate = new Date(systemToday);
    loadCalendarAroundDate(todayDate);
  }
});

// QUICK DATE JUMP
function jumpToDate() {
  const val = document.getElementById("jumpDate")?.value;
  if (!val) return;
  const [yyyy, mm, dd] = val.split("-");
  const jumpDateObj = new Date(yyyy, mm - 1, dd);
  todayDate = jumpDateObj;
  loadCalendarAroundDate(todayDate);
}

// STORING FULL DATES (YYYY-MM-DD)
function parseDateFromId(idStr) {
  // e.g. "5_6_2024" => "2024-06-05"
  const parts = idStr.split("_");
  if (parts.length !== 3) return null;
  let [month, day, year] = parts.map((p) => parseInt(p));
  const realMonth = month + 1; // months are 0-based in JS
  return `${year.toString().padStart(4,"0")}-${String(realMonth).padStart(2,"0")}-${String(day).padStart(2,"0")}`;
}

// STORE AND REMOVE VALUES
function storeValueForItemId(itemId) {
  pushUndoState();
  const item = document.getElementById(itemId);
  if (!item) return;
  const parentId = item.parentNode.id;
  localStorage[itemId] = item.value;

  // keep track of items in this parent day
  const parentIdsToItemIds = localStorage[parentId] ? localStorage[parentId].split(",") : [];
  if (!parentIdsToItemIds.includes(itemId)) {
    parentIdsToItemIds.push(itemId);
    localStorage[parentId] = parentIdsToItemIds;
  }

  // Also store in YYYY-MM-DD format for ICS usage
  const isoDate = parseDateFromId(parentId);
  if (isoDate) {
    localStorage[isoDate] = item.value;
  }

  localStorage.setItem("lastSavedTimestamp", Date.now());
}

function removeValueForItemId(itemId) {
  pushUndoState();
  delete localStorage[itemId];

  const item = document.getElementById(itemId);
  if (!item) return;
  const parentId = item.parentNode.id;
  if (localStorage[parentId]) {
    let parentIdsToItemIds = localStorage[parentId].split(",");
    parentIdsToItemIds = parentIdsToItemIds.filter((id) => id !== itemId);
    if (parentIdsToItemIds.length > 0) {
      localStorage[parentId] = parentIdsToItemIds;
    } else {
      delete localStorage[parentId];
    }
  }

  // Also remove ISO
  const isoDate = parseDateFromId(parentId);
  if (isoDate && localStorage[isoDate]) {
    delete localStorage[isoDate];
  }
}

// INFINITE CALENDAR LOGIC
var calendarTableElement;
var firstDate;
var lastDate;
var itemPaddingBottom = navigator.userAgent.indexOf("Firefox") !== -1 ? 2 : 0;

var months = [
  "January","February","March","April","May","June",
  "July","August","September","October","November","December"
];
var daysOfWeek = ["Mon","Tues","Wed","Thurs","Fri","Sat","Sun"];

function idForDate(date) {
  return date.getMonth() + "_" + date.getDate() + "_" + date.getFullYear();
}

function recalculateHeight(itemId) {
  const item = document.getElementById(itemId);
  if (!item) return;
  item.style.height = "0px";
  item.style.height = item.scrollHeight + itemPaddingBottom + "px";
}

function keydownHandler(e) {
  recalculateHeight(this.id);
  if (e.key === "Enter") {
    e.preventDefault();
    storeValueForItemId(this.id);
    this.blur();
    return false;
  } else {
    if (this.storeTimeout) clearTimeout(this.storeTimeout);
    this.storeTimeout = setTimeout(() => storeValueForItemId(this.id), 1000);
  }
}

function checkItem() {
  if (this.value.length === 0) {
    removeValueForItemId(this.id);
    this.parentNode.removeChild(this);
  }
}

function generateItem(parentId, itemId) {
  const item = document.createElement("textarea");
  const parent = document.getElementById(parentId);
  if (!parent) return null;
  parent.appendChild(item);
  item.id = itemId;
  item.onkeydown = keydownHandler;
  item.onblur = checkItem;
  item.spellcheck = false;
  return item;
}

// CLICK HANDLING
document.addEventListener("click", function(e) {
  const parentId = e.target.id;
  // only proceed if the clicked element's ID looks like "5_6_2024"
  if (!parentId || !parentId.includes("_")) return;

  const newItem = generateItem(parentId, nextItemId());
  if (newItem) {
    recalculateHeight(newItem.id);
    storeValueForItemId(newItem.id);
    newItem.focus();
  }
});

// GENERATE CALENDAR DAYS
function generateDay(dayCell, date) {
  // highlight weekends
  const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
  if (isWeekend) {
    dayCell.className += " weekend";
  }

  // highlight every-other-month
  const isShaded = (date.getMonth() % 2 === 1);
  if (isShaded) {
    dayCell.className += " shaded";
  }

  // highlight "today" (the user-chosen date)
  const isToday =
    date.getFullYear() === todayDate.getFullYear() &&
    date.getMonth() === todayDate.getMonth() &&
    date.getDate() === todayDate.getDate();
  if (isToday) {
    dayCell.className += " today";
  }

  dayCell.id = idForDate(date);
  dayCell.innerHTML = `
    <span>${daysOfWeek[getAdjustedDayIndex(date)]}
          ${months[date.getMonth()]}
          ${date.getDate()}</span>
  `;

  // retrieve existing notes for this day
  lookupItemsForParentId(dayCell.id, (items) => {
    for (const it of items) {
      const note = generateItem(dayCell.id, it.itemId);
      if (note) {
        note.value = it.itemValue;
        recalculateHeight(note.id);
      }
    }
  });
}

function getAdjustedDayIndex(date) {
  const day = date.getDay();
  // Monday=0 ... Sunday=6
  return day === 0 ? 6 : day - 1;
}

function prependWeek() {
  const weekRow = calendarTableElement.insertRow(0);
  let monthName = "";
  do {
    firstDate.setDate(firstDate.getDate() - 1);
    if (firstDate.getDate() === 1) {
      monthName = months[firstDate.getMonth()] + " " + firstDate.getFullYear();
    }
    const dayCell = weekRow.insertCell(0);
    generateDay(dayCell, new Date(firstDate));
  } while (getAdjustedDayIndex(firstDate) !== 0);
}

function appendWeek() {
  const weekRow = calendarTableElement.insertRow(-1);
  let monthName = "";
  do {
    lastDate.setDate(lastDate.getDate() + 1);
    if (lastDate.getDate() === 1) {
      monthName = months[lastDate.getMonth()] + " " + lastDate.getFullYear();
    }
    const dayCell = weekRow.insertCell(-1);
    generateDay(dayCell, new Date(lastDate));
  } while (getAdjustedDayIndex(lastDate) !== 6);

  // an "extra" cell for month name
  const extra = weekRow.insertCell(-1);
  extra.className = "extra";
  extra.innerHTML = monthName;
}

// SCROLLING & ANIMATION
function scrollPositionForElement(element) {
  let y = element.offsetTop;
  let node = element;
  while (node.offsetParent && node.offsetParent !== document.body) {
    node = node.offsetParent;
    y += node.offsetTop;
  }
  const clientHeight = element.clientHeight;
  return y - (window.innerHeight - clientHeight) / 2;
}

let startTime;
let startY;
let goalY;

function curve(x) {
  // cubic easing
  return (x < 0.5)
    ? (4 * x * x * x)
    : (1 - 4 * (1 - x) * (1 - x) * (1 - x));
}

function scrollAnimation() {
  const percent = (new Date() - startTime) / 1000;
  if (percent > 1) {
    window.scrollTo(0, goalY);
  } else {
    const newY = Math.round(startY + (goalY - startY) * curve(percent));
    window.scrollTo(0, newY);
    setTimeout(scrollAnimation, 10);
  }
}

function documentScrollTop() {
  let scrollTop = document.body.scrollTop;
  if (document.documentElement) {
    scrollTop = Math.max(scrollTop, document.documentElement.scrollTop);
  }
  return scrollTop;
}

function documentScrollHeight() {
  let scrollHeight = document.body.scrollHeight;
  if (document.documentElement) {
    scrollHeight = Math.max(scrollHeight, document.documentElement.scrollHeight);
  }
  return scrollHeight;
}

function scrollToToday() {
  const elem = document.getElementById(idForDate(todayDate));
  if (elem) {
    window.scrollTo(0, scrollPositionForElement(elem));
  }
}

function smoothScrollToToday() {
  const elem = document.getElementById(idForDate(todayDate));
  if (!elem) return;
  goalY = scrollPositionForElement(elem);
  startY = documentScrollTop();
  startTime = new Date();
  if (goalY !== startY) setTimeout(scrollAnimation, 10);
}

// POLL FUNCTION - INFINITE SCROLLING
function poll() {
  // add more weeks so user can scroll infinitely
  if (documentScrollTop() < 200) {
    const oldHeight = documentScrollHeight();
    for (let i = 0; i < 8; i++) {
      prependWeek();
    }
    window.scrollBy(0, documentScrollHeight() - oldHeight);
  } else if (
    documentScrollTop() >
    documentScrollHeight() - window.innerHeight - 200
  ) {
    for (let i = 0; i < 8; i++) {
      appendWeek();
    }
  }

  // Update system date if we cross midnight
  const newSysDate = new Date();
  if (
    newSysDate.getDate() !== systemToday.getDate() ||
    newSysDate.getMonth() !== systemToday.getMonth() ||
    newSysDate.getFullYear() !== systemToday.getFullYear()
  ) {
    systemToday = newSysDate;
  }
}

// LOAD CALENDAR AROUND DATE
function loadCalendarAroundDate(seedDate) {
  // Clear existing rows
  calendarTableElement.innerHTML = "";

  firstDate = new Date(seedDate);
  // find the Monday prior
  while (getAdjustedDayIndex(firstDate) !== 0) {
    firstDate.setDate(firstDate.getDate() - 1);
  }

  lastDate = new Date(firstDate);
  lastDate.setDate(lastDate.getDate() - 1);

  // fill initial weeks
  appendWeek();
  while (documentScrollHeight() <= window.innerHeight) {
    prependWeek();
    appendWeek();
  }

  setTimeout(scrollToToday, 50);
}

// HELPER FUNCTIONS
function nextItemId() {
  localStorage.nextId = localStorage.nextId ? parseInt(localStorage.nextId) + 1 : 0;
  return "item" + localStorage.nextId;
}

function lookupItemsForParentId(parentId, callback) {
  if (localStorage[parentId]) {
    const ids = localStorage[parentId].split(",");
    const itemList = [];
    for (const itemId of ids) {
      const itemValue = localStorage[itemId];
      if (itemValue !== undefined) {
        itemList.push({ itemId, itemValue });
      }
    }
    callback(itemList);
  }
}

function showHelp() {
  document.getElementById("help").style.display = "block";
}

function hideHelp() {
  document.getElementById("help").style.display = "none";
}

// DATA EXPORT/IMPORT FUNCTIONS
function downloadLocalStorageData() {
  var data = {};
  for (var key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  var downloadAnchorNode = document.createElement("a");
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", "calendar_data.json");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
}

function downloadBackupStorageData() {
  var data = {};
  for (var key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  var downloadAnchorNode = document.createElement("a");
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", "calendar_data_backup.json");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();

  alert(
    "A backup of your existing calendar data has been saved to your Downloads folder just in case."
  );
}

function loadDataFromFile() {
  var input = document.getElementById("fileInput");
  if (input.files.length === 0) {
    alert("Please select a file to load.");
    return;
  }
  var file = input.files[0];
  var reader = new FileReader();

  reader.onload = function (e) {
    try {
      var data = JSON.parse(e.target.result);
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          localStorage.setItem(key, data[key]);
        }
      }
      alert("Data loaded successfully!");
      location.reload(); // Reload to reflect the new data
    } catch (error) {
      alert("Invalid file format. Please select a valid JSON file.");
    }
  };

  reader.onerror = function () {
    alert("There was an error reading the file!");
  };

  reader.readAsText(file);
}

async function shouldLoadOrExport() {
  try {
    const handle = await window.showDirectoryPicker();
    const fileHandle = await handle.getFileHandle("calendar_data.json", { create: false });

    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);

    const fileTimestamp = data.lastSavedTimestamp;
    const localTimestamp = localStorage.getItem("lastSavedTimestamp");

    if (fileTimestamp && (!localTimestamp || fileTimestamp > localTimestamp)) {
      // Backup existing localStorage data
      downloadBackupStorageData();

      // Load data from file if it's newer
      await loadDataFromFileHandle(fileHandle);
      location.reload(); // Refresh to show loaded data
    } else {
      // Save data to file if local data is newer
      await exportToFileHandle(fileHandle);
    }
  } catch (err) {
    if (err.name === "AbortError") {
      console.log("User cancelled file/directory selection");
    } else {
      console.error("Error syncing data:", err);
      alert("There was an error syncing the calendar data. See console for details.");
    }
  }
}

async function loadDataFromFileHandle(fileHandle) {
  try {
    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);

    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        localStorage.setItem(key, data[key]);
      }
    }

    alert("Loaded calendar data from file.");
  } catch (err) {
    console.error("Error loading data from file:", err);
    alert("There was an error loading the calendar data. See console for details.");
  }
}

async function exportToFileHandle(fileHandle) {
  try {
    const writable = await fileHandle.createWritable();

    const data = {};
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        data[key] = localStorage.getItem(key);
      }
    }
    data.lastSavedTimestamp = Date.now();

    await writable.write(JSON.stringify(data));
    await writable.close();

    alert("Saved calendar data to file.");
  } catch (err) {
    console.error("Error saving data to file:", err);
    alert("There was an error saving the calendar data. See console for details.");
  }
}

// INITIALIZATION
window.onload = function () {
  calendarTableElement = document.getElementById("calendar");
  // Use the real system date as the initial focus
  todayDate = new Date(systemToday);
  loadCalendarAroundDate(todayDate);

  setInterval(poll, 100);
};
    </script>
</body>
</html>
