<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Timeless: The Infinite Calendar</title>

  <!-- Monospace + Additional Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">

  <style>
:root {
 --border-width: 1px;
 --border-color: black;
 --header-height: 27px;
 --shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* Reset / Base */
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Inter', sans-serif;
  background: white;
  color: black;
  transition: background-color 0.5s, color 0.5s;
}

/* Dark Mode */
body.dark-mode {
  background: #111;
  color: #eee;
}

/* Stylish Header (removed padding-bottom: 80px; ) */
#header {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
  border-bottom: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 20px;
  position: fixed;
  top: 0; left: 0; right: 0;
  height: var(--header-height);
  line-height: var(--header-height);
  z-index: 999;
}

body.dark-mode #header {
  background: linear-gradient(135deg, #2c3e50 0%, #1a1a2e 100%);
  box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
}

/* Container beneath the header, use margin-top for spacing */
#calendarContainer {
  margin-top: 100px; /* Instead of padding-bottom in the header */
  animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}

/* Timeless Title Button */
a.timeless {
  font-size: 137%;
  text-decoration: none;
  background: linear-gradient(to bottom, #E0E0E0, #CFE7FF);
  box-shadow: var(--shadow);
  color: #000;
  padding: 3px 10px;
  border-radius: 4px;
  display: inline-block;
  transition: background 0.3s, box-shadow 0.3s, transform 0.3s;
  margin-top: 10px;
  margin-bottom: 10px;
}
a.timeless:hover {
  background: linear-gradient(to bottom, #D0D0FF, #B0C0E7);
}
a.timeless:active {
  color: #FFF;
  background: linear-gradient(to bottom, #909090, #707070);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  transform: translateY(2px);
}

/* Buttons + Dark Mode variations */
a.button, button {
  font-size: 16px;
  padding: 8px 12px;
  border-radius: 20px;
  border: none;
  background: white;
  color: #444;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  margin: 0 5px;
  transition: all 0.3s;
  position: relative;
  text-decoration: none;
  display: inline-block;
  line-height: 15px;
}
a.button:hover, button:hover {
  background: #f8f9fa;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

body.dark-mode a.button, body.dark-mode button {
  background: #2d3748;
  color: #cbd5e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
body.dark-mode a.button:hover, body.dark-mode button:hover {
  background: #3a4a5e;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

/* Tooltip on button hover */
.button::after {
  content: attr(data-tooltip);
  position: absolute;
  top: 50%; right: 105%;
  transform: translateY(-50%);
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 1000;
}
.button:hover::after {
  opacity: 1;
  transform: translateY(-50%) translateX(-5px);
}

/* Date Picker with time range */
input[type="date"] {
  border-radius: 20px;
  border: 1px solid #ddd;
  padding: 6px 12px;
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type="date"][id="jumpDate"] {
  min: 2000-01-01;
  max: 2050-12-31;
}

body.dark-mode input[type="date"] {
  background: #2d3748;
  border-color: #4a5568;
  color: #cbd5e0;
}

/* Help Overlay */
#help {
  display: none;
  position: fixed;
  left: 0; right: 0;
  bottom: 0; top: 0;
  background: rgba(0, 0, 0, 0.75);
  z-index: 2000;
}
#help div {
  text-align: right;
  margin: 150px auto;
  width: 400px;
  height: 90px;
  padding: 20px;
  color: black;
  border-radius: 10px;
  box-shadow: var(--shadow);
  background: white;
}
#help ul {
  margin: 0;
  padding: 0 0 20px 20px;
  text-align: left;
  line-height: 15px;
}

/* The main calendar table */
#calendar {
  width: 960px;
  margin: 0 auto;
  table-layout: fixed;
  border-spacing: 3px;
  border: none;
}

/* Modern Rounded Cells & Subtle Borders:
   increased padding & radius for more "card-like" look */
#calendar td {
  padding: 12px 16px;
  border-radius: 10px;
  border: none;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
  margin: 2px;
  transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
  text-align: right;
  vertical-align: top;
  width: 120px;
  min-height: 100px;
  cursor: pointer;
  box-sizing: border-box;
  word-wrap: break-word;
  white-space: normal;
  overflow: visible;
}

/* Light hover color tweak */
#calendar td:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.1);
  background-color: rgba(0,0,0,0.02);
}

/* Dark mode for cells */
body.dark-mode #calendar td {
  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
}
body.dark-mode #calendar td:hover {
  box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
  background-color: rgba(255,255,255,0.05);
}

/* weekend / today / shading */
#calendar td.weekend {
  background: linear-gradient(to bottom right, #f8f9fa, #e9ecef);
}
body.dark-mode #calendar td.weekend {
  background: linear-gradient(to bottom right, #2d3748, #1a202c);
}

#calendar td.shaded {
  background: #CFE7FF;
}
body.dark-mode #calendar td.shaded {
  background: #333;
}

/* Animated "today" with a mild pulse */
@keyframes pulseToday {
  0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); }
  70% { box-shadow: 0 0 10px 20px rgba(220, 38, 38, 0); }
  100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
}
#calendar td.today {
  background: linear-gradient(135deg, rgba(229, 62, 62, 0.9) 0%, rgba(197, 48, 48, 0.9) 100%);
  transform: scale(1.03);
  z-index: 10;
  color: #FFF;
  font-weight: 600;
  animation: pulseToday 2s infinite;
}

/* Overwrite the box-shadow if you want a more dramatic effect:
   #calendar td.today {
     box-shadow: 0 8px 15px rgba(220, 38, 38, 0.3);
   }
*/

#calendar td.today span {
  color: white;
  background-color: rgba(0, 0, 0, 0.2);
  padding: 2px 5px;
  border-radius: 4px;
  display: inline-block;
  margin-bottom: 8px;
}

/* If you prefer short hover color or prefer the existing color, feel free to adjust. */

/* Using Playfair for month label */
#calendar td.extra {
  font-family: 'Playfair Display', serif;
  font-size: 22px;
  line-height: 1.2;
  color: #555;
  opacity: 0.8;
  font-weight: 400;
  padding: 0 0 0 15px;
  vertical-align: top;
  position: relative;
  top: 50%;
  transform: translateY(-50%);
  border-radius: 10px; /* Round corners for consistency */
  box-shadow: none;
  transition: opacity 0.3s, transform 0.3s;
  width: 120px;
  text-align: left;
  border: none;
  cursor: auto;
}
#calendar td.extra:hover {
  opacity: 1;
  transform: translateY(-50%) scale(1.02);
}

/* Dark mode for extra cell */
body.dark-mode #calendar td.extra {
  color: #aaa;
}

/* Make date display monospaced for clocklike alignment */
#calendar td span {
  font-size: 12px;
  font-weight: 500;
  letter-spacing: 0.5px;
  display: block;
  margin-bottom: 10px;
  font-family: 'Fira Code', monospace; /* Monospace for day & date */
  color: #666;
}
body.dark-mode #calendar td span {
  color: #aaa;
}

/* .clicked-day highlight for 0.5s */
.clicked-day {
  box-shadow: 0 0 0 3px rgba(80,160,255,0.5) !important;
  animation: clickedHighlight 0.5s forwards;
}
@keyframes clickedHighlight {
  0% { box-shadow: 0 0 0 3px rgba(80,160,255,0.5); }
  100% { box-shadow: none; }
}

/* .loading spinner indicator */
.loading {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  display: none;
}
.loading.active {
  display: block;
}
.loading:after {
  content: "";
  display: block;
  width: 40px; height: 40px;
  border-radius: 50%;
  border: 4px solid #ddd;
  border-top-color: #666;
  animation: spin 1s infinite linear;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
body.dark-mode .loading:after {
  border-color: #444;
  border-top-color: #bbb;
}

/* textareas: auto-height, shift+enter multiline, etc. */
textarea {
  font-family: 'Inter', sans-serif;
  padding: 8px;
  border-radius: 8px;
  background-color: rgba(255, 255, 255, 0.85);
  backdrop-filter: blur(5px);
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: background 0.3s, box-shadow 0.3s;
  color: #333;
  width: 100%;
  margin: 0 0 8px 0;
  min-height: 24px;
  line-height: 1.4;
  resize: none;
  box-sizing: border-box;
  display: block;
  overflow: hidden;
  word-wrap: break-word;
}
textarea:focus {
  background-color: rgba(255, 255, 255, 0.95);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  outline: none;
}
body.dark-mode textarea {
  background-color: rgba(45, 55, 72, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #cbd5e0;
}
body.dark-mode textarea:focus {
  background-color: rgba(45, 55, 72, 0.95);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* Inside today's cell, ensure contrast for textareas */
#calendar td.today textarea {
  background-color: rgba(255, 255, 255, 0.9);
  color: #333;
  border: 1px solid rgba(255, 255, 255, 0.3);
}
td.shaded textarea {
  background-color: rgba(255, 255, 255, 0.8);
}
body.dark-mode td.shaded textarea {
  background-color: rgba(60, 70, 90, 0.8);
}

#fileInput {
  display: none;
}
  </style>
</head>

<body>
  <div id="header">
    <a href="/" class="timeless">Timeless</a>
    <span>ü™ê</span>
    <div>
      <span>Timeless: The Infinite Calendar ‚ú®</span>
      <a href="#" class="button" onclick="toggleDarkMode()" data-tooltip="Toggle Dark Mode">üåô</a>
      <a href="#" class="button" onclick="downloadLocalStorageData()" data-tooltip="Download Calendar Data">üì•</a>
      <a href="#" class="button" onclick="document.getElementById('fileInput').click()" data-tooltip="Load Calendar Data">üíæ</a>
      <a href="#" class="button" onclick="smoothScrollToToday()" data-tooltip="Scroll to Today">üìÖ</a>
      <a href="#" class="button" onclick="shouldLoadOrExport()" data-tooltip="Sync with Cloud">üîÑ</a>
      <a href="#" class="button" onclick="showHelp()" data-tooltip="Help">‚ÑπÔ∏è</a>
      <input type="file" id="fileInput" onchange="loadDataFromFile()">

      <span>Jump to date:</span>
      <!-- Time range for date picker -->
      <input type="date" id="jumpDate" min="2000-01-01" max="2050-12-31">
      <button onclick="jumpToDate()">Go</button>
      <button onclick="undoLastChange()">Undo</button>
    </div>
  </div>

  <div id="help">
    <div>
      <ul>
        <li>Click on a day to add a note (Shift+Enter for multiple lines, Enter to save)</li>
        <li>To delete a note, just delete its text</li>
        <li>Press <code>‚Üë</code> or <code>‚Üì</code> to scroll, <code>T</code> to jump to Today</li>
      </ul>
      <a href="#" onclick="hideHelp()">Close</a>
    </div>
  </div>

  <div class="loading" id="loadingIndicator"></div>

  <div id="calendarContainer">
    <table id="calendar"></table>
  </div>

  <script>
/**
 * Timeless: The Infinitely Scrolling Calendar
 * by Jay Dixit
 **/

/* 1. systemToday vs. todayDate */
let systemToday = new Date();
let todayDate;

/* 2. Undo Stack */
let undoStack = [];
const MAX_UNDO = 5;

function pushUndoState() {
  const snapshot = {};
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      snapshot[key] = localStorage[key];
    }
  }
  undoStack.push(JSON.stringify(snapshot));
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
}
function undoLastChange() {
  if (undoStack.length === 0) {
    alert("No undo history available.");
    return;
  }
  // pop snapshot
  const lastSnapshotStr = undoStack.pop();
  if (!lastSnapshotStr) return;

  // restore localStorage from snapshot
  localStorage.clear();
  const snapshotData = JSON.parse(lastSnapshotStr);
  for (const key in snapshotData) {
    localStorage.setItem(key, snapshotData[key]);
  }

  // Re-render in place (no full reload)
  loadCalendarAroundDate(todayDate);

  // Optionally highlight that an undo occurred, or show a small toast:
  alert("Undo complete!");
}

/* Show/hide loading indicator */
function showLoading() {
  document.getElementById('loadingIndicator').classList.add('active');
}
function hideLoading() {
  document.getElementById('loadingIndicator').classList.remove('active');
}

/* 3. Keyboard Navigation + SHIFT+ENTER multiline */
document.addEventListener("keydown", (e) => {
  if (e.target && e.target.tagName.toLowerCase() === "textarea") return;

  if (e.key === "ArrowUp") {
    window.scrollBy(0, -window.innerHeight / 3);
  } else if (e.key === "ArrowDown") {
    window.scrollBy(0, window.innerHeight / 3);
  } else if (e.key === "t" || e.key === "T") {
    todayDate = new Date(systemToday);
    loadCalendarAroundDate(todayDate);
  }
});

/* 4. Quick Date Jump + Smooth Scroll */
function jumpToDate() {
  const val = document.getElementById("jumpDate")?.value;
  if (!val) return;

  showLoading();
  const [yyyy, mm, dd] = val.split("-");
  const jumpDateObj = new Date(yyyy, mm - 1, dd);
  todayDate = jumpDateObj;
  loadCalendarAroundDate(todayDate);

  setTimeout(() => {
    smoothScrollToToday();
  }, 300);
}

/* 5. Storing Full Dates */
function parseDateFromId(idStr) {
  const parts = idStr.split("_");
  if (parts.length !== 3) return null;
  let [month, day, year] = parts.map((p) => parseInt(p));
  const realMonth = month + 1;
  return `${year.toString().padStart(4,"0")}-${String(realMonth).padStart(2,"0")}-${String(day).padStart(2,"0")}`;
}

function storeValueForItemId(itemId) {
  pushUndoState();
  const item = document.getElementById(itemId);
  if (!item) return;
  const parentId = item.parentNode.id;
  localStorage[itemId] = item.value;

  const parentIds = localStorage[parentId] ? localStorage[parentId].split(",") : [];
  if (!parentIds.includes(itemId)) {
    parentIds.push(itemId);
    localStorage[parentId] = parentIds;
  }

  // Also store ISO date
  const isoDate = parseDateFromId(parentId);
  if (isoDate) {
    localStorage[isoDate] = item.value;
  }
  localStorage.setItem("lastSavedTimestamp", Date.now());
}

function removeValueForItemId(itemId) {
  pushUndoState();
  delete localStorage[itemId];

  const item = document.getElementById(itemId);
  if (!item) return;
  const parentId = item.parentNode.id;
  if (localStorage[parentId]) {
    let parentIds = localStorage[parentId].split(",");
    parentIds = parentIds.filter((id) => id !== itemId);
    if (parentIds.length > 0) {
      localStorage[parentId] = parentIds;
    } else {
      delete localStorage[parentId];
    }
  }

  // remove ISO
  const isoDate = parseDateFromId(parentId);
  if (isoDate && localStorage[isoDate]) {
    delete localStorage[isoDate];
  }
}

/* 6. Infinite Calendar Logic */
let calendarTableElement;
let firstDate, lastDate;
const itemPaddingBottom = (navigator.userAgent.indexOf("Firefox") !== -1) ? 2 : 0;

const months = [
  "January","February","March","April","May","June",
  "July","August","September","October","November","December"
];
const shortMonths = [
  "Jan","Feb","Mar","Apr","May","Jun",
  "Jul","Aug","Sep","Oct","Nov","Dec"
];
const daysOfWeek = ["Mon","Tues","Wed","Thurs","Fri","Sat","Sun"];

function idForDate(date) {
  return date.getMonth() + "_" + date.getDate() + "_" + date.getFullYear();
}

/* Auto-height for textareas */
function recalculateHeight(itemId) {
  const item = document.getElementById(itemId);
  if (!item) return;
  item.style.height = "0px";
  item.style.height = (item.scrollHeight + itemPaddingBottom) + "px";
}

/* SHIFT+Enter multiline vs Enter=save */
function keydownHandler(e) {
  recalculateHeight(this.id);

  // SHIFT+Enter => newline, Enter => save
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    storeValueForItemId(this.id);
    this.blur();
    return false;
  } else {
    if (this.storeTimeout) clearTimeout(this.storeTimeout);
    this.storeTimeout = setTimeout(() => storeValueForItemId(this.id), 1000);
  }
}

function checkItem() {
  if (this.value.length === 0) {
    removeValueForItemId(this.id);
    this.parentNode.removeChild(this);
  }
}

function generateItem(parentId, itemId) {
  const item = document.createElement("textarea");
  const parent = document.getElementById(parentId);
  if (!parent) return null;
  parent.appendChild(item);
  item.id = itemId;
  item.onkeydown = keydownHandler;
  item.onblur = checkItem;
  item.spellcheck = false;
  return item;
}

function lookupItemsForParentId(parentId, callback) {
  if (localStorage[parentId]) {
    const ids = localStorage[parentId].split(",");
    const itemList = [];
    for (const itemId of ids) {
      const itemValue = localStorage[itemId];
      if (itemValue !== undefined) {
        itemList.push({ itemId, itemValue });
      }
    }
    callback(itemList);
  }
}

/* 7. Handling day clicks + highlight clicked day */
document.addEventListener("click", (e) => {
  const td = e.target.closest("td");
  if (!td || !td.id || !td.id.includes("_")) return;

  // don't add a new note if user clicked on an existing note or "extra" cell
  if (e.target.tagName === "TEXTAREA" || td.className.includes("extra")) return;

  // highlight the cell briefly
  td.classList.add("clicked-day");
  setTimeout(() => {
    td.classList.remove("clicked-day");
  }, 500);

  const parentId = td.id;
  const newItem = generateItem(parentId, nextItemId());
  if (newItem) {
    recalculateHeight(newItem.id);
    storeValueForItemId(newItem.id);
    newItem.focus();
  }
});

/* Generate each day cell */
function generateDay(dayCell, date) {
  const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
  if (isWeekend) dayCell.className += " weekend";

  const isShaded = (date.getMonth() % 2 === 1);
  if (isShaded) dayCell.className += " shaded";

  const isToday =
    date.getFullYear() === todayDate.getFullYear() &&
    date.getMonth() === todayDate.getMonth() &&
    date.getDate() === todayDate.getDate();
  if (isToday) dayCell.className += " today";

  const isCurrentSystemDate =
    date.getFullYear() === systemToday.getFullYear() &&
    date.getMonth() === systemToday.getMonth() &&
    date.getDate() === systemToday.getDate();

  dayCell.id = idForDate(date);
  dayCell.innerHTML = `
    <span>
      ${daysOfWeek[getAdjustedDayIndex(date)]}
      ${shortMonths[date.getMonth()]}
      ${date.getDate()}
      ${isCurrentSystemDate && !isToday ? '<div class="current-day-dot"></div>' : ''}
    </span>
  `;
  lookupItemsForParentId(dayCell.id, (items) => {
    for (const it of items) {
      const note = generateItem(dayCell.id, it.itemId);
      if (note) {
        note.value = it.itemValue;
        recalculateHeight(note.id);
      }
    }
  });
}

/* For Monday=0 -> Sunday=6 */
function getAdjustedDayIndex(date) {
  const day = date.getDay();
  return (day === 0) ? 6 : day - 1;
}

function prependWeek() {
  const weekRow = calendarTableElement.insertRow(0);
  let monthName = "";
  do {
    firstDate.setDate(firstDate.getDate() - 1);
    if (firstDate.getDate() === 1) {
      monthName = months[firstDate.getMonth()] + " " + firstDate.getFullYear();
    }
    const dayCell = weekRow.insertCell(0);
    generateDay(dayCell, new Date(firstDate));
  } while (getAdjustedDayIndex(firstDate) !== 0);
}

function appendWeek() {
  const weekRow = calendarTableElement.insertRow(-1);
  let monthName = "";
  do {
    lastDate.setDate(lastDate.getDate() + 1);
    if (lastDate.getDate() === 1) {
      monthName = months[lastDate.getMonth()] + " " + lastDate.getFullYear();
    }
    const dayCell = weekRow.insertCell(-1);
    generateDay(dayCell, new Date(lastDate));
  } while (getAdjustedDayIndex(lastDate) !== 6);

  const extra = weekRow.insertCell(-1);
  extra.className = "extra";
  extra.innerHTML = monthName;
}

/* Scrolling, Animation, & Loading Indicators */
function scrollPositionForElement(element) {
  let y = element.offsetTop;
  let node = element;
  while (node.offsetParent && node.offsetParent !== document.body) {
    node = node.offsetParent;
    y += node.offsetTop;
  }
  const clientHeight = element.clientHeight;
  return y - (window.innerHeight - clientHeight) / 2;
}

let startTime, startY, goalY;
function curve(x) {
  return (x < 0.5) ? (4 * x * x * x) : (1 - 4 * (1 - x)*(1 - x)*(1 - x));
}
function scrollAnimation() {
  const percent = (new Date() - startTime) / 1000;
  if (percent > 1) {
    window.scrollTo(0, goalY);
    hideLoading();
  } else {
    const newY = Math.round(startY + (goalY - startY)*curve(percent));
    window.scrollTo(0, newY);
    setTimeout(scrollAnimation, 10);
  }
}

function documentScrollTop() {
  let scrollTop = document.body.scrollTop;
  if (document.documentElement) {
    scrollTop = Math.max(scrollTop, document.documentElement.scrollTop);
  }
  return scrollTop;
}
function documentScrollHeight() {
  let scrollHeight = document.body.scrollHeight;
  if (document.documentElement) {
    scrollHeight = Math.max(scrollHeight, document.documentElement.scrollHeight);
  }
  return scrollHeight;
}
function scrollToToday() {
  const elem = document.getElementById(idForDate(todayDate));
  if (elem) {
    window.scrollTo(0, scrollPositionForElement(elem));
    hideLoading();
  } else {
    hideLoading();
  }
}
function smoothScrollToToday() {
  showLoading();
  const elem = document.getElementById(idForDate(todayDate));
  if (!elem) {
    hideLoading();
    return;
  }
  goalY = scrollPositionForElement(elem);
  startY = documentScrollTop();
  startTime = new Date();
  if (goalY !== startY) setTimeout(scrollAnimation, 10);
  else hideLoading();
}

/* poll() for infinite scrolling & midnight crossing */
function poll() {
  if (documentScrollTop() < 200) {
    const oldHeight = documentScrollHeight();
    for (let i = 0; i < 8; i++) prependWeek();
    window.scrollBy(0, documentScrollHeight() - oldHeight);
  } else if (
    documentScrollTop() >
    documentScrollHeight() - window.innerHeight - 200
  ) {
    for (let i = 0; i < 8; i++) appendWeek();
  }

  // crossing midnight?
  const newSysDate = new Date();
  if (
    newSysDate.getDate() !== systemToday.getDate() ||
    newSysDate.getMonth() !== systemToday.getMonth() ||
    newSysDate.getFullYear() !== systemToday.getFullYear()
  ) {
    systemToday = newSysDate;
    const currentTodayElement = document.querySelector('.current-day-dot');
    if (!currentTodayElement) {
      location.reload();
    }
  }
}

/* loadCalendarAroundDate (no full reload) */
function loadCalendarAroundDate(seedDate) {
  showLoading();
  calendarTableElement.innerHTML = "";
  firstDate = new Date(seedDate);
  while (getAdjustedDayIndex(firstDate) !== 0) {
    firstDate.setDate(firstDate.getDate() - 1);
  }
  lastDate = new Date(firstDate);
  lastDate.setDate(lastDate.getDate() - 1);

  appendWeek();
  while (documentScrollHeight() <= window.innerHeight) {
    prependWeek();
    appendWeek();
  }
  setTimeout(() => {
    scrollToToday();
  }, 50);
}

/* Show/hide help overlay */
function showHelp() {
  document.getElementById("help").style.display = "block";
}
function hideHelp() {
  document.getElementById("help").style.display = "none";
}

/* Toggle Dark Mode */
function toggleDarkMode() {
  document.body.classList.toggle("dark-mode");
  if (document.body.classList.contains("dark-mode")) {
    localStorage.setItem("darkMode", "enabled");
  } else {
    localStorage.setItem("darkMode", "disabled");
  }
}
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark-mode");
}

/* Data load/save & Cloud sync omitted for brevity. */
/* ... But we keep them in the code below (unchanged). */

function downloadLocalStorageData() {
  showLoading();
  var data = {};
  for (var key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  var downloadAnchorNode = document.createElement("a");
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", "calendar_data.json");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
  setTimeout(hideLoading, 300);
}

function downloadBackupStorageData() {
  showLoading();
  var data = {};
  for (var key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  var downloadAnchorNode = document.createElement("a");
  downloadAnchorNode.setAttribute("href", dataStr);
  downloadAnchorNode.setAttribute("download", "calendar_data_backup.json");
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();

  setTimeout(() => {
    hideLoading();
    alert("A backup of your existing calendar data has been saved to your Downloads folder just in case.");
  }, 300);
}

function loadDataFromFile() {
  showLoading();
  var input = document.getElementById("fileInput");
  if (input.files.length === 0) {
    alert("Please select a file to load.");
    hideLoading();
    return;
  }
  var file = input.files[0];
  var reader = new FileReader();
  reader.onload = function(e) {
    try {
      var data = JSON.parse(e.target.result);
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          localStorage.setItem(key, data[key]);
        }
      }
      alert("Data loaded successfully!");
      location.reload();
    } catch (error) {
      hideLoading();
      alert("Invalid file format. Please select a valid JSON file.");
    }
  };
  reader.onerror = function() {
    hideLoading();
    alert("There was an error reading the file!");
  };
  reader.readAsText(file);
}

async function shouldLoadOrExport() {
  showLoading();
  try {
    const handle = await window.showDirectoryPicker();
    const fileHandle = await handle.getFileHandle("calendar_data.json", { create: false });
    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);

    const fileTimestamp = data.lastSavedTimestamp;
    const localTimestamp = localStorage.getItem("lastSavedTimestamp");

    if (fileTimestamp && (!localTimestamp || fileTimestamp > localTimestamp)) {
      downloadBackupStorageData();
      await loadDataFromFileHandle(fileHandle);
      location.reload();
    } else {
      await exportToFileHandle(fileHandle);
      hideLoading();
    }
  } catch (err) {
    hideLoading();
    if (err.name === "AbortError") {
      console.log("User cancelled file/directory selection");
    } else {
      console.error("Error syncing data:", err);
      alert("There was an error syncing the calendar data. See console for details.");
    }
  }
}

async function loadDataFromFileHandle(fileHandle) {
  try {
    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        localStorage.setItem(key, data[key]);
      }
    }
    alert("Loaded calendar data from file.");
  } catch (err) {
    hideLoading();
    console.error("Error loading data from file:", err);
    alert("There was an error loading the calendar data. See console for details.");
  }
}

async function exportToFileHandle(fileHandle) {
  try {
    const writable = await fileHandle.createWritable();
    const data = {};
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        data[key] = localStorage.getItem(key);
      }
    }
    data.lastSavedTimestamp = Date.now();
    await writable.write(JSON.stringify(data));
    await writable.close();
    alert("Saved calendar data to file.");
  } catch (err) {
    hideLoading();
    console.error("Error saving data to file:", err);
    alert("There was an error saving the calendar data. See console for details.");
  }
}

/* 8. Initialization */
window.onload = function () {
  calendarTableElement = document.getElementById("calendar");
  todayDate = new Date(systemToday);
  loadCalendarAroundDate(todayDate);
  setInterval(poll, 100);

  // Set initial jump date field to today's date
  const jumpDateField = document.getElementById("jumpDate");
  if (jumpDateField) {
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth() + 1).padStart(2, '0');
    const dd = String(today.getDate()).padStart(2, '0');
    jumpDateField.value = `${yyyy}-${mm}-${dd}`;
  }
};

/* Recalculate textareas on window resize */
window.addEventListener('resize', function() {
  const textareas = document.querySelectorAll('textarea');
  textareas.forEach(textarea => {
    recalculateHeight(textarea.id);
  });
});
  </script>
</body>
</html>
