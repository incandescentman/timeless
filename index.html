<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Timeless: The Infinite Calendar</title>

  <!-- Import fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&family=Fira+Code:wght@400;700&display=swap"
    rel="stylesheet"
  >

  <style>
/*
 * CSS Variables for consistent theming
 */
:root {
--border-width: 1px;
--border-color: black;
--header-height: 27px;
--shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
--cell-min-height: 120px;

 /* Light mode colors */
--bg-primary: white;
--bg-pattern: #e2e8f0;
--text-primary: black;
--weekend-gradient-from: #f8f9fa;
--weekend-gradient-to: #e9ecef;
--shaded-month: #CFE7FF;
--today-gradient-from: rgba(229, 62, 62, 0.9);
--today-gradient-to: rgba(197, 48, 48, 0.9);
--month-boundary: #aaa;
--header-gradient-from: #f8f9fa;
--header-gradient-to: #e9ecef;
--month-heading-bg: white;
--month-heading-text: #333;
}

/*
 * Dark mode colors
 */
body.dark-mode {
 --bg-primary: #222;
 --bg-pattern: rgba(255, 255, 255, 0.05);
 --text-primary: #eee;
 --weekend-gradient-from: #303542;
 --weekend-gradient-to: #232731;
 --shaded-month: #2a2a2a;
 --today-gradient-from: rgba(229, 62, 62, 0.8);
 --today-gradient-to: rgba(197, 48, 48, 0.8);
 --month-boundary: #555;
 --header-gradient-from: #2c3e50;
 --header-gradient-to: #1a1a2e;
 --month-heading-bg: #2c2c2c;
 --month-heading-text: #ddd;
}

/*
 * Base styles and resets
 */
html, body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  transition: background-color 0.5s, color 0.5s;
  background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
  background-size: 20px 20px;
}

/*
 * Fixed header bar styling
 */
#header {
  background: linear-gradient(135deg, var(--header-gradient-from) 0%, var(--header-gradient-to) 100%);
  box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
  border-bottom: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 20px;
  position: fixed;
  top: 0; left: 0; right: 0;
  height: var(--header-height);
  line-height: var(--header-height);
  z-index: 999; /* Keep header above all other content */
}

/*
 * A second fixed bar for the current month heading
 * Sits below #header
 */
#stickyMonthHeader {
  position: fixed;
top: calc(var(--header-height) + 20px);
  left: 0;
  width: 100%;
  font-family: 'Playfair Display', serif;
  font-size: 20px;
  font-weight: 600;
  padding: 5px 20px;
  background: var(--month-heading-bg);
  color: var(--month-heading-text);
  z-index: 998; /* Just below the main header */
  display: none; /* Becomes visible once we have a month name */
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  text-align: center;
  border-radius: 0 0 4px 4px;
  transition: background-color 0.3s, color 0.3s;
}

/*
 * Container for the calendar
 */
#calendarContainer {
  margin-top: 100px; /* avoid header overlap */
  animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}

/*
 * "Timeless" logo/link styling
 */
a.timeless {
  font-size: 137%;
  text-decoration: none;
  background: linear-gradient(to bottom, #E0E0E0, #CFE7FF);
  box-shadow: var(--shadow);
  color: #000;
  padding: 3px 10px;
  border-radius: 4px;
  display: inline-block;
  transition: background 0.3s, box-shadow 0.3s, transform 0.3s;
  margin-top: 10px;
  margin-bottom: 10px;
}
a.timeless:hover {
  background: linear-gradient(to bottom, #D0D0FF, #B0C0E7);
}
a.timeless:active {
  color: #FFF;
  background: linear-gradient(to bottom, #909090, #707070);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  transform: translateY(2px);
}

/*
 * Button styling
 */
a.button, button {
  font-size: 16px;
  padding: 8px 12px;
  border-radius: 20px;
  border: none;
  background: white;
  color: #444;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  margin: 0 5px;
  transition: all 0.3s;
  position: relative;
  text-decoration: none;
  display: inline-block;
  line-height: 15px;
}
a.button:hover, button:hover {
  background: #f8f9fa;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/*
 * Dark mode button styling
 */
body.dark-mode a.button, body.dark-mode button {
  background: #3a3a3a;
  color: #cbd5e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
body.dark-mode a.button:hover, body.dark-mode button:hover {
  background: #4a4a4a;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

/*
 * Tooltip for buttons
 */
.button::after {
  content: attr(data-tooltip);
  position: absolute;
  top: 50%; right: 105%;
  transform: translateY(-50%);
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 1000;
}
.button:hover::after {
  opacity: 1;
  transform: translateY(-50%) translateX(-5px);
}

/*
 * Date picker input styling
 */
input[type="date"] {
  border-radius: 20px;
  border: 1px solid #ddd;
  padding: 6px 12px;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
}
body.dark-mode input[type="date"] {
  background: #2d2d2d;
  border-color: #4a4a4a;
  color: #cbd5e0;
}

/*
 * Help overlay styling
 */
#help {
  display: none;
  position: fixed;
  left: 0; right: 0;
  bottom: 0; top: 0;
  background: rgba(0,0,0,0.75);
  z-index: 2000;
}
#help div {
  text-align: right;
  margin: 150px auto;
  width: 400px;
  height: auto;
  padding: 20px;
  color: black;
  border-radius: 10px;
  box-shadow: var(--shadow);
  background: white;
}
#help ul {
  margin: 0;
  padding: 0 0 20px 20px;
  text-align: left;
  line-height: 1.5;
}

/*
 * Main calendar table styling
 */
#calendar {
  width: 960px;
  margin: 0 auto;
  table-layout: fixed;
  border-spacing: 3px;
  border: none;
}

/*
 * Animate newly added rows
 */
.week-row-animate {
  animation: none;
}
@keyframes slideInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes slideInDown {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
.week-row-animate.append-animate {
  animation: slideInUp 0.3s ease-out forwards;
}
.week-row-animate.prepend-animate {
  animation: slideInDown 0.3s ease-out forwards;
}

/*
 * Calendar day cells
 */
#calendar td {
  padding: 12px 16px;
  border-radius: 10px;
  border: none;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
  margin: 2px;
  transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
  text-align: right;
  vertical-align: top;
  width: 120px;
  min-height: var(--cell-min-height);
  height: var(--cell-min-height);
  cursor: pointer;
  box-sizing: border-box;
  word-wrap: break-word;
  white-space: normal;
  overflow: visible;
  position: relative;
}

/*
 * Hover effect
 */
#calendar td:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.1);
  background-color: rgba(0,0,0,0.02);
}

/* Turn off pointer and hover styles for .extra cells */
#calendar td.extra {
  cursor: default;
  /* or 'text' if you want the I-beam cursor */
}

#calendar td.extra:hover {
  transform: none;
  box-shadow: none;
  background-color: transparent;
}


/*
 * Dark mode cell styling
 */
body.dark-mode #calendar td {
  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
}
body.dark-mode #calendar td:hover {
  box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
  background-color: rgba(255,255,255,0.05);
}

/*
 * Weekend styling (Saturday/Sunday)
 * Using CSS variables for gradient colors
 */
#calendar td.weekend {
  background: linear-gradient(to bottom right, var(--weekend-gradient-from), var(--weekend-gradient-to));
}

/*
 * Alternating month shading
 */
#calendar td.shaded {
  background: var(--shaded-month);
}

/*
 * "month-boundary" row => subtle top border
 */
tr.month-boundary td:not(.extra) {
  border-top: 2px solid var(--month-boundary) !important;
}

/*
 * Today's cell with pulse
 */
@keyframes pulseToday {
  0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); }
  70% { box-shadow: 0 0 10px 20px rgba(220, 38, 38, 0); }
  100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
}
#calendar td.today {
  background: linear-gradient(135deg, var(--today-gradient-from) 0%, var(--today-gradient-to) 100%);
  transform: scale(1.03);
  z-index: 10;
  color: #FFF;
  font-weight: 600;
  animation: pulseToday 2s infinite;
}

/*
 * Date text inside day cells
 */
#calendar td.today span {
  color: white;
  background-color: rgba(0,0,0,0.2);
  padding: 2px 5px;
  border-radius: 4px;
  display: inline-block;
  margin-bottom: 8px;
}

/*
 * Month label in rightmost column
 */
#calendar td.extra {
  font-family: 'Playfair Display', serif;
  font-size: 22px;
  line-height: 1.2;
  color: #555;
  opacity: 0.8;
  font-weight: 400;
  padding: 0 0 0 15px;
  vertical-align: middle;
  box-shadow: none;
  transition: opacity 0.5s ease, transform 0.5s ease;
  width: 120px;
  text-align: left;
  border: none;
  cursor: auto;
  min-height: var(--cell-min-height);
  height: var(--cell-min-height);
}
#calendar td.extra:hover {
  opacity: 1;
  transform: translateY(0) scale(1.02);
}
body.dark-mode #calendar td.extra {
  color: #aaa;
}

/*
 * Date display (monospace for alignment)
 */
#calendar td span {
  font-size: 12px;
  font-weight: 500;
  letter-spacing: 0.5px;
  display: block;
  margin-bottom: 10px;
  font-family: 'Fira Code', monospace;
  color: #666;
}
body.dark-mode #calendar td span {
  color: #aaa;
}

/*
 * Clicked-day animation
 */
.clicked-day {
  box-shadow: 0 0 0 3px rgba(80,160,255,0.5) !important;
  animation: clickedHighlight 0.5s forwards;
}
@keyframes clickedHighlight {
  0% { box-shadow: 0 0 0 3px rgba(80,160,255,0.5); }
  100% { box-shadow: none; }
}

/*
 * Date range selection styling
 */
.selected-range-start, .selected-range-end {
  background-color: rgba(66,153,225,0.6) !important;
  position: relative;
}
.selected-range-day {
  background-color: rgba(66,153,225,0.2) !important;
}
.selected-range-start:after {
  content: "Start";
  position: absolute;
  top: 5px; left: 5px;
  font-size: 10px;
  padding: 2px 4px;
  background-color: #4299e1;
  color: white;
  border-radius: 3px;
}
.selected-range-end:after {
  content: "End";
  position: absolute;
  top: 5px; left: 5px;
  font-size: 10px;
  padding: 2px 4px;
  background-color: #4299e1;
  color: white;
  border-radius: 3px;
}

/*
 * Loading spinner
 */
.loading {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  display: none;
}
.loading.active {
  display: block;
}
.loading:after {
  content: "";
  display: block;
  width: 40px; height: 40px;
  border-radius: 50%;
  border: 4px solid #ddd;
  border-top-color: #666;
  animation: spin 1s infinite linear;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
body.dark-mode .loading:after {
  border-color: #444;
  border-top-color: #bbb;
}

/*
 * Notes/tasks textarea
 */
textarea {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', sans-serif;
  padding: 8px;
  border-radius: 8px;
  background-color: rgba(255,255,255,0.85);
  backdrop-filter: blur(5px);
  border: 1px solid rgba(0,0,0,0.1);
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: background 0.3s, box-shadow 0.3s;
  color: #333;
  width: 100%;
  margin: 0 0 8px 0;
  min-height: 24px;
  line-height: 1.4;
  resize: none;
  box-sizing: border-box;
  display: block;
  overflow: hidden;
  white-space: normal;
  height: auto;
}
textarea:focus {
  background-color: rgba(255,255,255,0.95);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  outline: none;
}
body.dark-mode textarea {
  background-color: rgba(45,55,72,0.85);
  border: 1px solid rgba(255,255,255,0.1);
  color: #cbd5e0;
}
body.dark-mode textarea:focus {
  background-color: rgba(45,55,72,0.95);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/*
 * Special styling for textareas in today's cell
 */
#calendar td.today textarea {
  background-color: rgba(255,255,255,0.9);
  color: #333;
  border: 1px solid rgba(255,255,255,0.3);
}

/*
 * Special styling for textareas in shaded cells
 */
td.shaded textarea {
  background-color: rgba(255,255,255,0.8);
}
body.dark-mode td.shaded textarea {
  background-color: rgba(60,70,90,0.8);
}

/*
 * Dot for current system day if not "today"
 */
.current-day-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: linear-gradient(135deg, #38b2ac, #4fd1c5);
  box-shadow: 0 0 0 2px rgba(56,178,172,0.3);
  margin-left: 5px;
  vertical-align: middle;
}

/*
 * Accessibility: focus outlines
 */
textarea:focus, button:focus, a:focus, input:focus {
  outline: 2px solid #4299e1;
  outline-offset: 2px;
}
body.dark-mode textarea:focus,
body.dark-mode button:focus,
body.dark-mode a:focus,
body.dark-mode input:focus {
  outline-color: #63b3ed;
}

/*
 * Toast notification
 */
#toast-container {
  position: fixed;
  bottom: 20px; right: 20px;
  z-index: 9999;
}
.toast {
  background-color: rgba(0,0,0,0.8);
  color: white;
  padding: 10px 15px;
  border-radius: 4px;
  margin-top: 10px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  opacity: 0;
  transition: opacity 0.3s ease;
}
body.dark-mode .toast {
  background-color: rgba(255,255,255,0.2);
  box-shadow: 0 2px 5px rgba(0,0,0,0.4);
}

/*
 * Year view overlay
 */
#yearViewContainer {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: white;
  z-index: 2000;
  overflow: auto;
  padding: 20px;
}
body.dark-mode #yearViewContainer {
  background: #222;
}

#yearViewGrid {
  display: grid;
  grid-template-columns: repeat(4,1fr);
  gap: 20px;
  max-width: 1200px;
  margin: 0 auto;
}
.month-grid {
  text-align: center;
}
.month-grid h3 {
  margin-bottom: 10px;
}
.month-grid table {
  width: 100%;
  border-collapse: collapse;
}
.month-grid th, .month-grid td {
  padding: 3px;
  text-align: center;
}

/*
 * Responsive styling
 */
@media (max-width: 1000px) {
  #calendar {
    width: 100%;
    max-width: 960px;
  }
  #header {
    flex-direction: column;
    height: auto;
    padding: 10px;
  }
  #header>div {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
  #calendarContainer {
    margin-top: 140px;
  }
  #yearViewGrid {
    grid-template-columns: repeat(3,1fr);
  }
}
@media (max-width:768px) {
  #calendar td {
    padding: 8px;
  }
  #header span:not(:first-child) {
    display: none;
  }
  #yearViewGrid {
    grid-template-columns: repeat(2,1fr);
  }
}
@media (max-width:480px) {
  #yearViewGrid {
    grid-template-columns: repeat(1,1fr);
  }
}

/*
 * Print styles
 */
@media print {
  #header, #help, .loading, button, .yearViewContainer, #stickyMonthHeader {
    display: none !important;
  }
  #calendarContainer {
    margin-top: 0;
  }
  #calendar {
    width: 100%;
  }
  #calendar td {
    box-shadow: none;
    border: 1px solid #ddd;
  }
  #calendar td.today {
    background: none !important;
    color: black !important;
    transform: none !important;
    animation: none !important;
    border: 2px solid #e53e3e !important;
  }
  #calendar td.today span {
    color: black !important;
    background: none !important;
  }
  #calendar td.weekend, #calendar td.shaded {
    background: none !important;
    border: 1px solid #ddd;
  }
  #calendar td.weekend {
    background-color: #f8f9fa !important;
  }
  @page {
    size: landscape;
    margin: 1cm;
  }
}

/*
 * Hide file input (for load button)
 */
#fileInput {
  display: none;
}
  </style>
</head>
<body>

<!-- Fixed header -->
<div id="header">
  <a href="/" class="timeless" aria-label="Timeless Calendar Home">Timeless</a>
  <span>ü™ê</span>
  <div>
    <span>Timeless: The Infinite Calendar ‚ú®</span>
    <a href="#" class="button" onclick="toggleDarkMode()" data-tooltip="Toggle Dark Mode">üåô</a>
    <a href="#" class="button" onclick="downloadLocalStorageData()" data-tooltip="Download Calendar Data">üì•</a>
    <a href="#" class="button" onclick="document.getElementById('fileInput').click()" data-tooltip="Load Calendar Data">üíæ</a>
    <a href="#" class="button" onclick="smoothScrollToToday()" data-tooltip="Scroll to Today">üìÖ</a>
    <a href="#" class="button" onclick="showYearView()" data-tooltip="Year View">üìÜ</a>
    <a href="#" class="button" onclick="toggleRangeSelection()" data-tooltip="Select Date Range">üìè</a>
    <a href="#" class="button" onclick="shouldLoadOrExport()" data-tooltip="Sync with Cloud">üîÑ</a>
    <a href="#" class="button" onclick="showHelp()" data-tooltip="Help">‚ÑπÔ∏è</a>
    <input type="file" id="fileInput" onchange="loadDataFromFile()">

    <span>Jump to date:</span>
    <input type="date" id="jumpDate" min="2000-01-01" max="2050-12-31">
    <button onclick="jumpToDate()" aria-label="Go to selected date">Go</button>
    <button onclick="undoLastChange()" aria-label="Undo last change">Undo</button>
  </div>
</div>

<!-- Sticky month heading that updates as you scroll -->
<div id="stickyMonthHeader"></div>

<!-- Help overlay -->
<div id="help">
  <div>
    <ul>
      <li>Click on a day to add a note (Shift+Enter for multi-line, Enter to save)</li>
      <li>To delete a note, just delete its text</li>
      <li>Press <code>‚Üë</code> or <code>‚Üì</code> to scroll, <code>T</code> to jump to Today</li>
      <li>Press <code>Ctrl+D</code> to toggle dark mode</li>
      <li>Use the Date Range button (üìè) to select a range of dates</li>
      <li>Click Year View (üìÜ) to see the entire year at a glance</li>
    </ul>
    <a href="#" onclick="hideHelp()">Close</a>
  </div>
</div>

<!-- Loading spinner -->
<div class="loading" id="loadingIndicator"></div>

<!-- Main calendar container -->
<div id="calendarContainer">
  <div id="top-sentinel"></div>
  <table id="calendar"></table>
  <div id="bottom-sentinel"></div>
</div>

<!-- Year view overlay -->
<div id="yearViewContainer">
  <div style="text-align:center; margin-bottom:20px;">
    <h2 id="yearViewTitle">2023 at a Glance</h2>
    <button onclick="hideYearView()">Close</button>
  </div>
  <div id="yearViewGrid"></div>
</div>

<script>
/**************
 * Timeless: The Infinitely Scrolling Calendar
 * Incorporating requested enhancements:
 *  1) Sticky Month Headings
 *  2) Animated row transitions
 *  3) Month boundaries
 *  4) Improved dark-mode palette
 *  5) Debounce over setTimeout for auto-save
 *  6) More descriptive variable names
 **************/

/****
 * CORE VARIABLES & STATE
 ****/
let systemToday = new Date(); // current real system date
let todayDate;                // "selected" today in the calendar
let calendarTableElement;
let firstDate, lastDate;

// For undo functionality
let undoStack = [];
const MAX_UNDO = 5;

// For date range selection
let rangeStart = null;
let rangeEnd = null;
let isSelectingRange = false;

// For row animation
const ROW_ANIMATION_CLASS = 'week-row-animate';

// Day & month names
const daysOfWeek = ["Mon","Tues","Wed","Thur","Fri","Sat","Sun"];
const months = [
  "January","February","March","April","May","June",
  "July","August","September","October","November","December"
];
const shortMonths = [
  "Jan","Feb","Mar","Apr","May","Jun",
  "Jul","Aug","Sep","Oct","Nov","Dec"
];

// For smooth scrolling
let startTime, startY, goalY;

// Current visible month (for sticky header)
let currentVisibleMonth = '';

/****
 * UTILITY
 ****/

/* Adds a fade/slide animation to a newly inserted row. */
function animateRowInsertion(row, direction = 'append') {
  row.classList.add(ROW_ANIMATION_CLASS);

  // Add the appropriate animation class based on direction
  if (direction === 'append') {
    row.classList.add('append-animate');
  } else {
    row.classList.add('prepend-animate');
  }

  // Remove animation classes after animation completes
  row.addEventListener('animationend', () => {
    row.classList.remove(ROW_ANIMATION_CLASS, 'append-animate', 'prepend-animate');
  }, { once: true });
}

/* Standard throttle to limit function calls. */
function throttle(func, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}

/* Standard debounce to ensure a function runs only after wait time has elapsed since last call. */
function debounce(fn, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn.apply(this, args), wait);
  };
}

/* Return day index with Monday=0, Sunday=6. */
function getAdjustedDayIndex(date) {
  const day = date.getDay();
  return (day === 0) ? 6 : day - 1;
}

/* Return an ID for a date, e.g. "0_17_2025" => month_day_year. */
function idForDate(date) {
  return date.getMonth() + "_" + date.getDate() + "_" + date.getFullYear();
}

/* Parse "month_day_year" => YYYY-MM-DD. */
function parseDateFromId(idStr) {
  const parts = idStr.split("_");
  if (parts.length !== 3) return null;
  const [month, day, year] = parts.map(Number);
  const realMonth = month + 1;
  return `${year.toString().padStart(4,"0")}-${String(realMonth).padStart(2,"0")}-${String(day).padStart(2,"0")}`;
}

/* Show a toast notification. */
function showToast(message, duration = 3000) {
  let toastContainer = document.getElementById('toast-container');
  if (!toastContainer) {
    toastContainer = document.createElement('div');
    toastContainer.id = 'toast-container';
    document.body.appendChild(toastContainer);
  }
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  toastContainer.appendChild(toast);

  // fade in
  requestAnimationFrame(() => {
    toast.style.opacity = '1';
  });

  // fade out & remove
  setTimeout(() => {
    toast.style.opacity = '0';
    setTimeout(() => {
      if (toastContainer.contains(toast)) {
        toastContainer.removeChild(toast);
      }
    }, 300);
  }, duration);
}

/* Show/hide the loading spinner. */
function showLoading() {
  document.getElementById('loadingIndicator').classList.add('active');
}
function hideLoading() {
  document.getElementById('loadingIndicator').classList.remove('active');
}

/****
 * DARK MODE
 ****/
function toggleDarkMode() {
  document.body.classList.toggle("dark-mode");
  if (document.body.classList.contains("dark-mode")) {
    localStorage.setItem("darkMode", "enabled");
    showToast("Dark mode enabled");
  } else {
    localStorage.setItem("darkMode", "disabled");
    showToast("Light mode enabled");
  }
}

/****
 * UNDO STACK
 ****/
function pushUndoState() {
  const snapshot = {};
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      snapshot[key] = localStorage[key];
    }
  }
  undoStack.push(JSON.stringify(snapshot));
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
}
function undoLastChange() {
  if (undoStack.length === 0) {
    showToast("No undo history available");
    return;
  }
  const lastSnapshotStr = undoStack.pop();
  if (!lastSnapshotStr) return;

  // restore localStorage
  localStorage.clear();
  const snapshotData = JSON.parse(lastSnapshotStr);
  for (const key in snapshotData) {
    localStorage.setItem(key, snapshotData[key]);
  }

  // Re-render in place
  loadCalendarAroundDate(todayDate);
  showToast("Changes undone successfully");
}

/****
 * SCROLL & POSITION
 ****/
/* Current scroll position. */
function documentScrollTop() {
  return Math.max(document.body.scrollTop, document.documentElement.scrollTop);
}
/* Document total scroll height. */
function documentScrollHeight() {
  return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
}

/* Smooth scroll logic. */
function curve(x) {
  return (x < 0.5) ? (4 * x * x * x) : (1 - 4 * (1 - x)*(1 - x)*(1 - x));
}
function scrollAnimation() {
  const percent = (new Date() - startTime) / 1000;
  if (percent > 1) {
    window.scrollTo(0, goalY);
    hideLoading();
  } else {
    const newY = Math.round(startY + (goalY - startY)*curve(percent));
    window.scrollTo(0, newY);
    setTimeout(scrollAnimation, 10);
  }
}

/* Center an element vertically in the viewport. */
function scrollPositionForElement(element) {
  let y = element.offsetTop;
  let node = element;
  while (node.offsetParent && node.offsetParent !== document.body) {
    node = node.offsetParent;
    y += node.offsetTop;
  }
  const clientHeight = element.clientHeight;
  return y - (window.innerHeight - clientHeight)/2;
}

/* Scroll immediately to today's date. */
function scrollToToday() {
  const elem = document.getElementById(idForDate(todayDate));
  if (elem) {
    window.scrollTo(0, scrollPositionForElement(elem));
  }
  hideLoading();
}

/* Smoothly scroll to today's date. */
function smoothScrollToToday() {
  showLoading();
  const elem = document.getElementById(idForDate(todayDate));
  if (!elem) {
    hideLoading();
    return;
  }
  goalY = scrollPositionForElement(elem);
  startY = documentScrollTop();
  startTime = new Date();
  if (goalY !== startY) setTimeout(scrollAnimation, 10);
  else hideLoading();
}

/****
 * TEXTAREA / NOTES
 ****/
/* Recompute textarea height based on content. */
function recalculateHeight(itemId) {
  const noteTextarea = document.getElementById(itemId);
  if (!noteTextarea) return;

  // Reset height to accurately measure content
  noteTextarea.style.height = "0";
  const scrollHeight = noteTextarea.scrollHeight;

  // Set new height with a little padding to avoid clipping
  noteTextarea.style.height = (scrollHeight + 5) + "px";
}

/* Ensure all existing textareas have correct heights. */
function recalculateAllHeights() {
  const textareas = document.querySelectorAll('textarea');
  textareas.forEach(ta => recalculateHeight(ta.id));
}

/* Store note text to localStorage. */
function storeValueForItemId(itemId) {
  pushUndoState();
  const noteTextarea = document.getElementById(itemId);
  if (!noteTextarea) return;
  const parentId = noteTextarea.parentNode.id;
  localStorage[itemId] = noteTextarea.value;

  // track references
  const parentIds = localStorage[parentId] ? localStorage[parentId].split(",") : [];
  if (!parentIds.includes(itemId)) {
    parentIds.push(itemId);
    localStorage[parentId] = parentIds;
  }

  // Also store ISO date
  const isoDate = parseDateFromId(parentId);
  if (isoDate) {
    localStorage[isoDate] = noteTextarea.value;
  }
  localStorage.setItem("lastSavedTimestamp", Date.now());
}

/* Remove empty note. */
function removeValueForItemId(itemId) {
  pushUndoState();
  delete localStorage[itemId];
  const noteTextarea = document.getElementById(itemId);
  if (!noteTextarea) return;
  const parentId = noteTextarea.parentNode.id;
  if (localStorage[parentId]) {
    let parentIds = localStorage[parentId].split(",");
    parentIds = parentIds.filter(id => id !== itemId);
    if (parentIds.length) {
      localStorage[parentId] = parentIds;
    } else {
      delete localStorage[parentId];
    }
  }
  // remove ISO date
  const isoDate = parseDateFromId(parentId);
  if (isoDate && localStorage[isoDate]) {
    delete localStorage[isoDate];
  }
}

/* Debounced keydown handler for textareas. */
function noteKeyDownHandler(e) {
  recalculateHeight(this.id);

  // SHIFT+Enter => newline, Enter => save & blur
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    storeValueForItemId(this.id);
    this.blur();
    return false;
  } else {
    // Use debounce to avoid spamming localStorage
    if (!this.debouncedSave) {
      this.debouncedSave = debounce(() => storeValueForItemId(this.id), 1000);
    }
    this.debouncedSave();
  }
}

/* Blur => remove item if empty. */
function noteBlurHandler() {
  if (!this.value.trim()) {
    removeValueForItemId(this.id);
    this.parentNode.removeChild(this);
  }
}

/* Create a new textarea note in a given cell. */
function generateItem(parentId, itemId) {
  const parentCell = document.getElementById(parentId);
  if (!parentCell) return null;
  const noteTextarea = document.createElement("textarea");
  noteTextarea.id = itemId;
  noteTextarea.onkeydown = noteKeyDownHandler;
  noteTextarea.onblur = noteBlurHandler;
  noteTextarea.spellcheck = false;
  parentCell.appendChild(noteTextarea);
  return noteTextarea;
}

/* Retrieve note items for a cell from localStorage. */
function lookupItemsForParentId(parentId, callback) {
  if (localStorage[parentId]) {
    const ids = localStorage[parentId].split(",");
    const itemList = [];
    ids.forEach(itemId => {
      const itemValue = localStorage[itemId];
      if (itemValue !== undefined) {
        itemList.push({ itemId, itemValue });
      }
    });
    callback(itemList);
  }
}

/****
 * CALENDAR RENDER
 ****/
function generateDay(dayCell, date) {
  // weekend?
  const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
  if (isWeekend) dayCell.classList.add("weekend");

  // alternate shading
  const isShaded = (date.getMonth() % 2 === 1);
  if (isShaded) dayCell.classList.add("shaded");

  // highlight today's date
  const isToday = (
    date.getFullYear() === todayDate.getFullYear() &&
    date.getMonth() === todayDate.getMonth() &&
    date.getDate() === todayDate.getDate()
  );
  if (isToday) {
    dayCell.classList.add("today");
  }

  // system date if different
  const isCurrentSystemDate = (
    date.getFullYear() === systemToday.getFullYear() &&
    date.getMonth() === systemToday.getMonth() &&
    date.getDate() === systemToday.getDate()
  );

  dayCell.id = idForDate(date);
  dayCell.innerHTML = `
    <span>
      ${daysOfWeek[getAdjustedDayIndex(date)]}
      ${shortMonths[date.getMonth()]}
      ${date.getDate()}
      ${isCurrentSystemDate && !isToday ? '<div class="current-day-dot"></div>' : ''}
    </span>
  `;
  // load existing notes
  lookupItemsForParentId(dayCell.id, items => {
    items.forEach(item => {
      const note = generateItem(dayCell.id, item.itemId);
      if (note) {
        note.value = item.itemValue;
        recalculateHeight(note.id);
      }
    });
  });
}

/* Generate the next row on top. */
function prependWeek() {
  const weekRow = calendarTableElement.insertRow(0);

  // We'll animate newly inserted rows
  animateRowInsertion(weekRow, 'prepend');

  // Track if this row starts a new month
  let isMonthBoundary = false;
  let monthName = "";

  do {
    firstDate.setDate(firstDate.getDate() - 1);
    // if day is 1 => new month
    if (firstDate.getDate() === 1) {
      monthName = months[firstDate.getMonth()] + " " + firstDate.getFullYear();
      isMonthBoundary = true;
    }
    const dayCell = weekRow.insertCell(0);
    generateDay(dayCell, new Date(firstDate));
  } while (getAdjustedDayIndex(firstDate) !== 0);

  // If this is the first day of a month, mark the row
  if (isMonthBoundary) {
    weekRow.classList.add('month-boundary');
  }

  // Store month name for sticky heading
  weekRow.dataset.monthName = months[firstDate.getMonth()] + " " + firstDate.getFullYear();
}

/* Generate the next row at bottom. */
function appendWeek() {
  const weekRow = calendarTableElement.insertRow(-1);
  animateRowInsertion(weekRow, 'append');

  // Track if this row starts a new month
  let isMonthBoundary = false;
  let monthName = "";

  // First cell's date will be used to determine the row's month
  const rowStartDate = new Date(lastDate);
  rowStartDate.setDate(rowStartDate.getDate() + 1);
  const rowMonthName = months[rowStartDate.getMonth()] + " " + rowStartDate.getFullYear();

  do {
    lastDate.setDate(lastDate.getDate() + 1);
    if (lastDate.getDate() === 1) {
      monthName = months[lastDate.getMonth()] + " " + lastDate.getFullYear();
      isMonthBoundary = true;
    }
    const dayCell = weekRow.insertCell(-1);
    generateDay(dayCell, new Date(lastDate));
  } while (getAdjustedDayIndex(lastDate) !== 6);

  // If the week crosses a month boundary, mark it
  if (isMonthBoundary) {
    weekRow.classList.add('month-boundary');
  }

// Rightmost month label logic
const extra = weekRow.insertCell(-1);
extra.className = "extra";

if (isMonthBoundary) {
  extra.innerHTML = months[lastDate.getMonth()] + " " + lastDate.getFullYear();
} else {
  extra.innerHTML = "";
}

  // Store month name for sticky heading
  weekRow.dataset.monthName = rowMonthName;
}

/****
 * STICKY MONTH HEADER
 ****/
/*
 * On scroll, figure out which row is at the top of the viewport
 * and display that row's month name in #stickyMonthHeader.
 */
function updateStickyMonthHeader() {
  const rows = document.querySelectorAll('#calendar tr');

  // Offset from top to account for the fixed header
  const headerOffset = document.getElementById('header').offsetHeight + 30;

  let visibleMonth = null;

  // Find the first row that's visible in the viewport
  for (const row of rows) {
    const rect = row.getBoundingClientRect();
    // Check if the top of the row is in the viewport, accounting for header
    if (rect.top >= headerOffset && rect.top <= window.innerHeight) {
      visibleMonth = row.dataset.monthName;
      break;
    }
    // Also consider rows that are partially visible (top is above viewport but bottom is visible)
    if (rect.top < headerOffset && rect.bottom > headerOffset) {
      visibleMonth = row.dataset.monthName;
      break;
    }
  }

  // Update the sticky header if we found a visible month
  const stickyHeader = document.getElementById('stickyMonthHeader');
  if (visibleMonth && visibleMonth !== currentVisibleMonth) {
    currentVisibleMonth = visibleMonth;
    stickyHeader.textContent = visibleMonth;
    stickyHeader.style.display = 'block';
  }
}

/****
 * RANGE SELECTION
 ****/
function toggleRangeSelection() {
  isSelectingRange = !isSelectingRange;
  if (!isSelectingRange) {
    clearRangeSelection();
  }
  showToast(isSelectingRange ? "Select range start date" : "Range selection cancelled");
}
function clearRangeSelection() {
  document.querySelectorAll('.selected-range-start, .selected-range-end, .selected-range-day')
    .forEach(el => el.classList.remove('selected-range-start','selected-range-end','selected-range-day'));
  rangeStart = null;
  rangeEnd = null;
}

function handleRangeSelection(dayCell) {
  const dateId = dayCell.id;
  if (!dateId) return;
  const [month, day, year] = dateId.split('_').map(Number);
  const selectedDate = new Date(year, month, day);

  if (!rangeStart) {
    rangeStart = selectedDate;
    dayCell.classList.add('selected-range-start');
    showToast("Select range end date");
  } else if (!rangeEnd) {
    if (selectedDate < rangeStart) {
      // swap
      rangeEnd = rangeStart;
      rangeStart = selectedDate;
      document.querySelector('.selected-range-start')?.classList.remove('selected-range-start');
      dayCell.classList.add('selected-range-start');
      // also mark the old start as end
      document.querySelectorAll('td').forEach(cell => {
        if (cell.id === idForDate(rangeEnd)) {
          cell.classList.add('selected-range-end');
        }
      });
    } else {
      rangeEnd = selectedDate;
      dayCell.classList.add('selected-range-end');
    }
    highlightDaysInRange();
    showToast(`Selected: ${rangeStart.toDateString()} to ${rangeEnd.toDateString()}`);
    isSelectingRange = false;
  }
}
function highlightDaysInRange() {
  if (!rangeStart || !rangeEnd) return;
  const curDate = new Date(rangeStart);
  while (curDate < rangeEnd) {
    curDate.setDate(curDate.getDate() + 1);
    const dayId = idForDate(curDate);
    const dayCell = document.getElementById(dayId);
    if (dayCell &&
       !dayCell.classList.contains('selected-range-start') &&
       !dayCell.classList.contains('selected-range-end')) {
      dayCell.classList.add('selected-range-day');
    }
  }
}

/****
 * CLICK HANDLERS
 ****/
document.addEventListener('click', (evt) => {
  const dayCell = evt.target.closest("td");
  if (!dayCell || !dayCell.id || !dayCell.id.includes("_")) return;
  if (evt.target.tagName === "TEXTAREA" || dayCell.className.includes("extra")) return;

  if (isSelectingRange) {
    handleRangeSelection(dayCell);
    return;
  }
  // quick highlight
  dayCell.classList.add("clicked-day");
  setTimeout(() => dayCell.classList.remove("clicked-day"), 500);

  // create a new note
  const parentId = dayCell.id;
  const newItem = generateItem(parentId, nextItemId());
  if (newItem) {
    recalculateHeight(newItem.id);
    storeValueForItemId(newItem.id);
    newItem.focus();
  }
});

/****
 * KEYBOARD NAV
 ****/
document.addEventListener("keydown", (e) => {
  if (e.target && e.target.tagName.toLowerCase() === "textarea") return;
  if (e.key === "ArrowUp") {
    window.scrollBy(0, -window.innerHeight/3);
  } else if (e.key === "ArrowDown") {
    window.scrollBy(0, window.innerHeight/3);
  } else if (e.key === "t" || e.key === "T") {
    todayDate = new Date(systemToday);
    loadCalendarAroundDate(todayDate);
  } else if ((e.ctrlKey || e.metaKey) && e.key === 'd' && !e.shiftKey && !e.altKey) {
    e.preventDefault();
    toggleDarkMode();
  }
});

/****
 * JUMP & LOAD
 ****/
function jumpToDate() {
  const val = document.getElementById("jumpDate")?.value;
  if (!val) return;
  showLoading();
  const [yyyy, mm, dd] = val.split("-");
  const jumpDateObj = new Date(yyyy, mm-1, dd);
  todayDate = jumpDateObj;
  loadCalendarAroundDate(todayDate);
  setTimeout(() => smoothScrollToToday(), 300);
}

/* Generate a unique item ID. */
function nextItemId() {
  localStorage.nextId = localStorage.nextId ? parseInt(localStorage.nextId)+1 : 0;
  return "item" + localStorage.nextId;
}

/****
 * INFINITE SCROLL
 ****/
function checkInfiniteScroll() {
  // near top => prepend
  if (documentScrollTop() < 200) {
    const oldHeight = documentScrollHeight();
    for (let i=0; i<8; i++) prependWeek();
    window.scrollBy(0, documentScrollHeight() - oldHeight);
    recalculateAllHeights();
  }
  // near bottom => append
  else if (documentScrollTop() > documentScrollHeight() - window.innerHeight - 200) {
    for (let i=0; i<8; i++) appendWeek();
    recalculateAllHeights();
  }

  // If system day changed, reload
  const newSysDate = new Date();
  if (newSysDate.toDateString() !== systemToday.toDateString()) {
    systemToday = newSysDate;
    // If there's no .current-day-dot in the doc, we can reload
    if (!document.querySelector('.current-day-dot')) {
      location.reload();
    }
  }
}

/****
 * YEAR VIEW
 ****/
function showYearView() {
  const year = todayDate.getFullYear();
  document.getElementById('yearViewTitle').textContent = `${year} at a Glance`;
  const container = document.getElementById('yearViewGrid');
  container.innerHTML = '';

  for (let month = 0; month < 12; month++) {
    const monthDiv = document.createElement('div');
    monthDiv.className = 'month-grid';

    const monthTitle = document.createElement('h3');
    monthTitle.textContent = months[month];
    monthDiv.appendChild(monthTitle);

    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';

    // day-of-week header
    const headerRow = document.createElement('tr');
    for (let i=0; i<7; i++) {
      const tableHeader = document.createElement('th');
      tableHeader.textContent = daysOfWeek[i].charAt(0);
      tableHeader.style.padding = '3px';
      tableHeader.style.textAlign = 'center';
      headerRow.appendChild(tableHeader);
    }
    table.appendChild(headerRow);

    // first day of this month
    const firstDayOfMonth = new Date(year, month, 1);
    let dayOfWeek = getAdjustedDayIndex(firstDayOfMonth);
    const daysInMonth = new Date(year, month+1, 0).getDate();

    let day = 1;
    let row = document.createElement('tr');

    // empty cells before first day
    for (let i=0; i<dayOfWeek; i++) {
      const emptyCell = document.createElement('td');
      emptyCell.style.padding = '3px';
      emptyCell.style.textAlign = 'center';
      row.appendChild(emptyCell);
    }

    // fill days
    while (day <= daysInMonth) {
      if (dayOfWeek === 7) {
        table.appendChild(row);
        row = document.createElement('tr');
        dayOfWeek = 0;
      }
      const dayCell = document.createElement('td');
      dayCell.textContent = day;
      dayCell.style.padding = '3px';
      dayCell.style.textAlign = 'center';

      const currentDate = new Date(year, month, day);
      if (currentDate.getTime() === todayDate.setHours(0,0,0,0)) {
        dayCell.style.backgroundColor = '#e53e3e';
        dayCell.style.color = 'white';
        dayCell.style.borderRadius = '50%';
      }

      // bold if there's data
      const dateId = `${month}_${day}_${year}`;
      if (localStorage[dateId]) {
        dayCell.style.fontWeight = 'bold';
        dayCell.style.textDecoration = 'underline';
      }

      // clickable => jump
      dayCell.style.cursor = 'pointer';
      dayCell.onclick = () => {
        hideYearView();
        todayDate = new Date(year, month, day);
        loadCalendarAroundDate(todayDate);
        smoothScrollToToday();
      };

      row.appendChild(dayCell);
      day++;
      dayOfWeek++;
    }
    if (row.hasChildNodes()) {
      table.appendChild(row);
    }
    monthDiv.appendChild(table);
    container.appendChild(monthDiv);
  }
  document.getElementById('yearViewContainer').style.display = 'block';
}
function hideYearView() {
  document.getElementById('yearViewContainer').style.display = 'none';
}

/****
 * CALENDAR INITIALIZATION
 ****/
function loadCalendarAroundDate(seedDate) {
  showLoading();
  calendarTableElement.innerHTML = "";
  firstDate = new Date(seedDate);

  // find start of that week
  while (getAdjustedDayIndex(firstDate) !== 0) {
    firstDate.setDate(firstDate.getDate() - 1);
  }
  lastDate = new Date(firstDate);
  lastDate.setDate(lastDate.getDate() - 1);

  // initial week
  appendWeek();

  // fill viewport
  while (documentScrollHeight() <= window.innerHeight) {
    prependWeek();
    appendWeek();
  }

  setTimeout(() => {
    scrollToToday();
    recalculateAllHeights();
    // Initial month header update
    updateStickyMonthHeader();
  }, 50);
}

/****
 * UI CONTROLS
 ****/
function showHelp() {
  document.getElementById("help").style.display = "block";
}
function hideHelp() {
  document.getElementById("help").style.display = "none";
}

/****
 * FILE PERSISTENCE
 ****/
function downloadLocalStorageData() {
  showLoading();
  const data = {};
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  const anchor = document.createElement("a");
  anchor.setAttribute("href", dataStr);
  anchor.setAttribute("download", "calendar_data.json");
  document.body.appendChild(anchor);
  anchor.click();
  anchor.remove();
  setTimeout(() => {
    hideLoading();
    showToast("Calendar data downloaded");
  }, 300);
}

function loadDataFromFile() {
  showLoading();
  const input = document.getElementById("fileInput");
  if (!input.files.length) {
    showToast("Please select a file to load");
    hideLoading();
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          localStorage.setItem(key, data[key]);
        }
      }
      showToast("Data loaded successfully!");
      location.reload();
    } catch {
      hideLoading();
      showToast("Invalid file format. Please select a valid JSON file.");
    }
  };
  reader.onerror = () => {
    hideLoading();
    showToast("There was an error reading the file!");
  };
  reader.readAsText(file);
}

/* For cloud sync (Web File System API). */
async function shouldLoadOrExport() {
  showLoading();
  try {
    const handle = await window.showDirectoryPicker();
    const fileHandle = await handle.getFileHandle("calendar_data.json",{create:false});
    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);

    const fileTimestamp = data.lastSavedTimestamp;
    const localTimestamp = localStorage.getItem("lastSavedTimestamp");

    if (fileTimestamp && (!localTimestamp || fileTimestamp>localTimestamp)) {
      // local is older => backup local then load from file
      downloadBackupStorageData();
      await loadDataFromFileHandle(fileHandle);
      location.reload();
    } else {
      // local is newer => export
      await exportToFileHandle(fileHandle);
      hideLoading();
    }
  } catch(err) {
    hideLoading();
    if (err.name === "AbortError") {
      console.log("User cancelled file/directory selection");
    } else {
      console.error("Error syncing data:", err);
      showToast("Error syncing calendar data. See console for details.");
    }
  }
}
function downloadBackupStorageData() {
  showLoading();
  const data = {};
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      data[key] = localStorage.getItem(key);
    }
  }
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
  const anchor = document.createElement("a");
  anchor.setAttribute("href", dataStr);
  anchor.setAttribute("download", "calendar_data_backup.json");
  document.body.appendChild(anchor);
  anchor.click();
  anchor.remove();
  setTimeout(() => {
    hideLoading();
    showToast("Calendar data backup created", 5000);
  }, 300);
}
async function loadDataFromFileHandle(fileHandle) {
  try {
    const file = await fileHandle.getFile();
    const contents = await file.text();
    const data = JSON.parse(contents);
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        localStorage.setItem(key, data[key]);
      }
    }
    showToast("Loaded calendar data from file");
  } catch(err) {
    hideLoading();
    console.error("Error loading data from file:", err);
    showToast("Error loading calendar data");
  }
}
async function exportToFileHandle(fileHandle) {
  try {
    const writable = await fileHandle.createWritable();
    const data = {};
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        data[key] = localStorage.getItem(key);
      }
    }
    data.lastSavedTimestamp = Date.now();
    await writable.write(JSON.stringify(data));
    await writable.close();
    showToast("Saved calendar data to file");
  } catch(err) {
    hideLoading();
    console.error("Error saving data to file:", err);
    showToast("Error saving calendar data");
  }
}

/****
 * INIT
 ****/
window.onload = function() {
  calendarTableElement = document.getElementById("calendar");
  todayDate = new Date(systemToday);
  loadCalendarAroundDate(todayDate);

  // IntersectionObserver fallback
  if ('IntersectionObserver' in window) {
    setupScrollObservers();
  } else {
    setInterval(checkInfiniteScroll, 100);
  }

  // set jump date to today
  const jumpDateField = document.getElementById("jumpDate");
  if (jumpDateField) {
    const sysDate = new Date();
    jumpDateField.value = `${sysDate.getFullYear()}-${String(sysDate.getMonth()+1).padStart(2,'0')}-${String(sysDate.getDate()).padStart(2,'0')}`;
  }

  // apply dark mode if stored
  if (localStorage.getItem("darkMode") === "enabled") {
    document.body.classList.add("dark-mode");
  }

  // re-check note heights
  setTimeout(recalculateAllHeights, 100);

  // listen for scroll => update sticky month
  window.addEventListener('scroll', throttle(updateStickyMonthHeader, 100));

  // Initial call to set the sticky header
  updateStickyMonthHeader();
};

/* IntersectionObservers for infinite scroll if available. */
function setupScrollObservers() {
  const options = { rootMargin: '200px' };

  const topSentinelObserver = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      const oldHeight = documentScrollHeight();
      for (let i=0; i<8; i++) prependWeek();
      window.scrollBy(0, documentScrollHeight() - oldHeight);
      recalculateAllHeights();
      updateStickyMonthHeader();
    }
  }, options);

  const bottomSentinelObserver = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      for (let i=0; i<8; i++) appendWeek();
      recalculateAllHeights();
      updateStickyMonthHeader();
    }
  }, options);

  topSentinelObserver.observe(document.getElementById('top-sentinel'));
  bottomSentinelObserver.observe(document.getElementById('bottom-sentinel'));

  // also watch system day changes
  setInterval(() => {
    const newSysDate = new Date();
    if (newSysDate.toDateString() !== systemToday.toDateString()) {
      systemToday = newSysDate;
      if (!document.querySelector('.current-day-dot')) {
        location.reload();
      }
    }
  }, 60000);
}
</script>
</body>
</html>
