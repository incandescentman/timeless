#+TITLE: Calendar Virtualization Plan - Infinite Scroll Implementation
#+DATE: 2025-10-05
#+AUTHOR: Claude
#+TAGS: virtualization, infinite-scroll, performance, architecture
#+STATUS: Draft

#+BEGIN_COMMENT
LLM_CONTEXT:
- Purpose: Complete analysis and implementation plan for infinite scroll
- Key Decision: Remove artificial date constraints in favor of true infinite scroll
- Always read before: Implementing scroll changes or debugging scroll issues
- Related Docs: [[file:../codebase-wisdom.org::*Mobile Safari Crash][codebase-wisdom.org::*Mobile Safari Crash]], [[file:../design-architecture.org][design-architecture.org]]
#+END_COMMENT

* Executive Summary

**Goal:** Support scrolling backward to 2020 and forward to 2030+, or implement true infinite scroll (whichever is easier).

**Recommendation:** Implement true infinite scroll by removing artificial date constraints. This is simpler, more robust, and leverages the existing sliding window architecture.

**Key Insight:** The current month-window sliding architecture already prevents DOM bloat. The ~minRange~ constraints are artificial limitations that add complexity without performance benefit.

**Effort:** ~40 lines of code changes (removals/simplifications), 30 minutes implementation.

* Current Architecture Analysis

** Sliding Window Approach
The calendar uses a sophisticated month-window system with IntersectionObserver sentinels:

1. **Window Management**
   - Renders a sliding window of months (mobile: 4 max, desktop: 18 max)
   - Top/bottom sentinels trigger loading more months when visible
   - Guards prevent runaway loads (critical for iOS Safari - see [[file:../codebase-wisdom.org::*Mobile Safari Crash][codebase-wisdom.org]])
   - Window slides forward/backward, trimming the opposite edge

2. **Current Configuration** (src/components/Calendar.jsx)
   #+begin_src javascript
   const MOBILE_CONFIG = {
     initialRange: { before: 1, after: 2 },  // 3 months initially
     maxMonths: 4,                           // Max 4 months in DOM
     loadMonths: 1,                          // Load 1 month at a time
     minRange: { before: -60, after: 24 }    // ~2020 to 2027 limit
   };

   const DESKTOP_CONFIG = {
     initialRange: { before: 6, after: 6 },  // 12 months initially
     maxMonths: 18,                          // Max 18 months in DOM
     loadMonths: 3,                          // Load 3 months at a time
     minRange: { before: -360, after: 360 }  // 30 years each way
   };
   #+end_src

3. **Sentinel-Based Loading** (src/components/Calendar.jsx:189-237)
   - IntersectionObserver watches top/bottom sentinels
   - Flags prevent duplicate loads while sentinel is visible
   - Scroll compensation maintains position when prepending months
   - Functional state updates avoid stale closures

** Why Current Limits Exist
Desktop config allows ±30 years (minRange: ±360 months), but mobile is constrained to ~2020-2027. This appears to be:
1. An abundance of caution after mobile Safari crashes
2. Assumed correlation between date range and performance

** Critical Realization
The ~maxMonths~ constraint (4 mobile, 18 desktop) **already limits DOM size**. The date range (minRange) is independent of DOM performance. You could scroll from 1900 to 2100 and still only have 4-18 months rendered at any time.

* Proposed Solution: True Infinite Scroll

** Phase 1: Remove Artificial Limits (Recommended) ⭐

*** Rationale
- Leverages existing sliding window (battle-tested since Mobile Safari crash fixes)
- No arbitrary date cutoffs to maintain
- Simpler code = fewer bugs = easier maintenance
- Naturally handles edge cases (users born in 1950, planning for 2050)
- Performance is controlled by ~maxMonths~, not date range

*** Implementation Steps

**** Step 1.1: Remove minRange from Configs
File: ~src/components/Calendar.jsx~ (lines 11-23)

#+begin_src javascript
// BEFORE
const MOBILE_CONFIG = {
  initialRange: { before: 1, after: 2 },
  maxMonths: 4,
  loadMonths: 1,
  minRange: { before: -60, after: 24 }  // REMOVE THIS
};

const DESKTOP_CONFIG = {
  initialRange: { before: 6, after: 6 },
  maxMonths: 18,
  loadMonths: 3,
  minRange: { before: -360, after: 360 }  // REMOVE THIS
};

// AFTER
const MOBILE_CONFIG = {
  initialRange: { before: 1, after: 2 },
  maxMonths: 4,  // DOM size limit (still needed!)
  loadMonths: 1
  // minRange: removed - allow infinite scroll
};

const DESKTOP_CONFIG = {
  initialRange: { before: 6, after: 6 },
  maxMonths: 18,
  loadMonths: 3
  // minRange: removed
};
#+end_src

**** Step 1.2: Simplify extendMonthRange Function
File: ~src/components/Calendar.jsx~ (lines 33-67)

#+begin_src javascript
// BEFORE (complex with minRange handling)
function extendMonthRange(range, direction, load, max, minRange) {
  let { start, end } = range;

  if (direction === 'prev') {
    start -= load;
  } else {
    end += load;
  }

  const total = end - start + 1;
  if (total > max) {
    if (direction === 'prev') {
      end = start + max - 1;
    } else {
      start = end - (max - 1);
    }
  }

  // Complex minRange clamping logic
  if (minRange) {
    const minStart = minRange.before ?? Number.NEGATIVE_INFINITY;
    const maxEnd = minRange.after ?? Number.POSITIVE_INFINITY;

    if (start < minStart) {
      start = minStart;
      end = Math.max(start, start + max - 1);
    }

    if (end > maxEnd) {
      end = maxEnd;
      start = Math.min(end, end - (max - 1));
    }
  }

  return { start, end };
}

// AFTER (simplified - only window size management)
function extendMonthRange(range, direction, load, max) {
  let { start, end } = range;

  if (direction === 'prev') {
    start -= load;
  } else {
    end += load;
  }

  // Enforce sliding window size limit
  const total = end - start + 1;
  if (total > max) {
    if (direction === 'prev') {
      end = start + max - 1;
    } else {
      start = end - (max - 1);
    }
  }

  return { start, end };
}
#+end_src

**** Step 1.3: Update Function Calls
File: ~src/components/Calendar.jsx~

Lines 82-85 (config destructuring):
#+begin_src javascript
// BEFORE
const { maxMonths, loadMonths, minRange } = useMemo(
  () => (isMobile ? MOBILE_CONFIG : DESKTOP_CONFIG),
  [isMobile]
);

// AFTER
const { maxMonths, loadMonths } = useMemo(
  () => (isMobile ? MOBILE_CONFIG : DESKTOP_CONFIG),
  [isMobile]
);
#+end_src

Line 170 (loadPreviousMonths):
#+begin_src javascript
// BEFORE
setMonthRange(prev => extendMonthRange(prev, 'prev', loadMonths, maxMonths, minRange));

// AFTER
setMonthRange(prev => extendMonthRange(prev, 'prev', loadMonths, maxMonths));
#+end_src

Line 185 (loadNextMonths):
#+begin_src javascript
// BEFORE
setMonthRange(prev => extendMonthRange(prev, 'next', loadMonths, maxMonths, minRange));

// AFTER
setMonthRange(prev => extendMonthRange(prev, 'next', loadMonths, maxMonths));
#+end_src

*** Performance Impact
**None.** The sliding window (~maxMonths~) already limits DOM size. Removing date constraints only simplifies the code.

*** Backward Compatibility
- Event storage is already date-agnostic (stores ISO date strings)
- No changes needed to CalendarContext or storage.js
- Existing events from any date will continue to work

** Phase 2: Enhanced UX (Optional Additions)

*** 2.1: "Far From Today" Indicator
When user scrolls >6 months from today, show a quick-return button:

#+begin_src jsx
// Add to Calendar.jsx after month sections
const visibleMonthOffset = useMemo(() => {
  // Calculate offset of first visible month from today
  const firstVisible = monthsToRender[0];
  if (!firstVisible) return 0;

  const todayMonth = systemToday.getMonth();
  const todayYear = systemToday.getFullYear();
  const firstMonth = firstVisible.month;
  const firstYear = firstVisible.year;

  return (firstYear - todayYear) * 12 + (firstMonth - todayMonth);
}, [monthsToRender, systemToday]);

// In render:
{Math.abs(visibleMonthOffset) > 6 && (
  <div className="far-from-today-hint">
    <button onClick={goToToday}>
      ↻ Back to Today ({months[systemToday.getMonth()]} {systemToday.getFullYear()})
    </button>
  </div>
)}
#+end_src

Styling (src/styles/calendar.css):
#+begin_src css
.far-from-today-hint {
  position: fixed;
  bottom: 2rem;
  right: 2rem;
  z-index: 1000;
}

.far-from-today-hint button {
  padding: 0.75rem 1.5rem;
  background: rgba(239, 68, 68, 0.9); /* red-600 with opacity */
  color: white;
  border: none;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.far-from-today-hint button:hover {
  background: rgba(220, 38, 38, 0.9); /* red-700 with opacity */
}
#+end_src

*** 2.2: Performance Monitoring (Development Only)
Add temporary logging to validate DOM size stays bounded:

#+begin_src javascript
// Add to useEffect in Calendar.jsx (remove after validation)
useEffect(() => {
  if (process.env.NODE_ENV === 'development') {
    console.log({
      monthsRendered: monthsToRender.length,
      domNodes: document.querySelectorAll('.day-cell').length,
      range: `${monthRange.start} to ${monthRange.end}`,
      expectedMaxCells: maxMonths * 5 * 7  // max months × ~5 weeks × 7 days
    });
  }
}, [monthsToRender, monthRange, maxMonths]);
#+end_src

Expected output:
- Mobile: ~140 cells (4 months × ~5 weeks × 7 days)
- Desktop: ~630 cells (18 months × ~5 weeks × 7 days)

** Phase 3: Documentation Updates

*** 3.1: Update codebase-wisdom.org
Add entry documenting the decision:

#+begin_src org
* Infinite Scroll: Why We Don't Limit Date Ranges
  Date: 2025-10-05

** The Decision
  Removed artificial date range constraints (minRange) in favor of true infinite scroll.

** The Truth
  The sliding window architecture already prevents DOM bloat by maintaining a fixed
  number of rendered months (mobile: 4, desktop: 18). Date range constraints were
  solving a problem that doesn't exist.

** Why This Works
  1. **DOM size is controlled by maxMonths** - Not by date range
  2. **Scroll position compensation** - Works regardless of date (see Mobile Safari crash fix)
  3. **Sentinel guards** - Prevent runaway loads (see Mobile Safari crash fix)
  4. **Memory usage** - Bounded by window size, not date range

** Performance Proof
  - Mobile: ~140 DOM nodes (4 months × 5 weeks × 7 days) whether scrolling through 2020 or 2050
  - Desktop: ~630 DOM nodes (18 months × 5 weeks × 7 days) regardless of year
  - Window slides: Old months removed as new months added

** Benefits
  - Simpler code (removed ~20 lines of minRange logic)
  - Fewer edge cases to test
  - Handles all use cases: past event logging, far-future planning, users born in 1950
  - No arbitrary cutoffs to maintain as years pass

** Prevention Checklist
  - [ ] Don't reintroduce date range limits without measuring actual DOM impact
  - [ ] Trust the sliding window - it's battle-tested (survived Mobile Safari crash fixes)
  - [ ] If performance issues arise, adjust maxMonths, not date ranges
#+end_src

*** 3.2: Update design-architecture.org
Add note in "Future Considerations" section:

#+begin_src org
** Infinite Scroll Architecture

The calendar supports true infinite scrolling in both directions (past and future).
This is possible because:

1. **Sliding Window**: Only renders a fixed number of months (mobile: 4, desktop: 18)
2. **Sentinel Loading**: IntersectionObserver triggers loading at edges
3. **Automatic Trimming**: Old months removed as new months added
4. **DOM Bounded**: Performance is constant regardless of date range

See: [[file:codebase-wisdom.org::*Infinite Scroll: Why We Don't Limit Date Ranges][codebase-wisdom.org::*Infinite Scroll]]
#+end_src

* Alternative Approach: Conservative Limits (NOT Recommended)

If you prefer hard limits for 2020-2030 (though I don't recommend this):

#+begin_src javascript
const MOBILE_CONFIG = {
  initialRange: { before: 1, after: 2 },
  maxMonths: 4,
  loadMonths: 1,
  minRange: { before: -60, after: 60 }  // Oct 2020 to Oct 2030
};

const DESKTOP_CONFIG = {
  initialRange: { before: 6, after: 6 },
  maxMonths: 18,
  loadMonths: 3,
  minRange: { before: -60, after: 60 }  // Same range
};
#+end_src

** Why I Don't Recommend This
- Requires updating limits as years pass (2030 will be "too close" in 2028)
- Arbitrary cutoff at 2030 (what about planning for 2031?)
- More code to maintain (minRange clamping logic)
- No real benefit (sliding window already handles performance)
- Creates user friction ("Why can't I add my birthday from 1985?")

* Testing Checklist

After implementing Phase 1:

** Functional Tests
- [ ] Scroll backward rapidly on mobile - no crashes
- [ ] Scroll backward to 2020, 2010, 2000 - months render correctly
- [ ] Scroll forward to 2030, 2040, 2050 - months render correctly
- [ ] Create event in 2020, verify it saves/loads from localStorage
- [ ] Create event in 2035, verify it saves/loads
- [ ] Scroll to today via "t" keyboard shortcut from far past/future

** Performance Tests
- [ ] Check DOM node count on mobile stays ~140 cells
- [ ] Check DOM node count on desktop stays ~630 cells
- [ ] Verify scroll position compensation when loading previous months
  (height delta fix from [[file:../codebase-wisdom.org::*Mobile Safari Crash][codebase-wisdom.org::*Mobile Safari Crash]])
- [ ] No memory leaks during extended scroll sessions (use Chrome DevTools Memory profiler)

** Guard Tests (Critical - these prevent iOS crashes)
- [ ] Sentinel guards prevent runaway loads (sentinelLoadRef.current)
- [ ] Only one load triggered per sentinel intersection
- [ ] Sentinel resets when leaving viewport
- [ ] Fast scrolling doesn't trigger multiple simultaneous loads

** Navigation Tests
- [ ] Keyboard navigation (n/p) works across year boundaries
- [ ] Keyboard navigation (N/P) jumps full years correctly
- [ ] Month navigation doesn't break at 2020 or 2030
- [ ] Year view shows correct years from any scroll position

** Edge Cases
- [ ] Leap year handling (Feb 2024, Feb 2028, etc.)
- [ ] Month boundary transitions (Jan→Feb, Dec→Jan)
- [ ] Weekend highlighting across years
- [ ] Today highlighting works regardless of scroll position

* Implementation Timeline

** Immediate (30 minutes)
- Remove minRange constraints (Phase 1)
- Update function signatures
- Test on mobile and desktop
- Commit: "Remove artificial date constraints for infinite scroll"

** Optional (1-2 hours)
- Add "far from today" indicator (Phase 2.1)
- Add performance monitoring (Phase 2.2)
- Update documentation (Phase 3)
- Commit: "Add infinite scroll UX enhancements"

* Files to Modify

** Phase 1 (Required)
- ~src/components/Calendar.jsx~ (~40 lines changed)
  - Lines 11-23: Remove minRange from configs
  - Lines 33-67: Simplify extendMonthRange function
  - Lines 82-85: Remove minRange from destructuring
  - Line 170: Remove minRange parameter from loadPreviousMonths call
  - Line 185: Remove minRange parameter from loadNextMonths call

** Phase 2 (Optional)
- ~src/components/Calendar.jsx~ (~30 lines added)
  - Add visibleMonthOffset calculation
  - Add far-from-today hint rendering
- ~src/styles/calendar.css~ (~20 lines added)
  - Add .far-from-today-hint styles

** Phase 3 (Optional)
- ~docs/codebase-wisdom.org~ (~40 lines added)
  - New section: "Infinite Scroll: Why We Don't Limit Date Ranges"
- ~docs/design-architecture.org~ (~10 lines added)
  - Update "Future Considerations" section

* Risk Analysis

** Low Risk
- Changes are primarily removals (simpler code)
- Sliding window architecture is battle-tested
- Guards prevent runaway loads (proven during Mobile Safari crash fixes)
- Performance is bounded by maxMonths, not date range

** Medium Risk (Mitigated)
- User scrolls too far and gets lost
  → Mitigation: "Far from today" indicator (Phase 2.1)
  → Mitigation: Existing "t" shortcut returns to today

** No Risk
- Performance degradation
  → DOM size is constant (maxMonths constraint)
- Memory leaks
  → React component unmounting handles cleanup
- Data corruption
  → Event storage is already date-agnostic

* Success Metrics

** Objective Measures
- DOM node count stays ≤ maxMonths × 5 weeks × 7 days
- No increase in memory usage during scroll sessions
- No sentinel-related crashes on mobile Safari
- Event creation/loading works for any date

** Subjective Measures
- Users can naturally explore past years for event logging
- Users can plan far into the future without artificial limits
- Developer experience: simpler code, fewer edge cases

* Conclusion

**Recommendation:** Implement Phase 1 (true infinite scroll) immediately.

**Rationale:**
1. Simpler than maintaining arbitrary date limits
2. More robust (fewer edge cases)
3. Better UX (no artificial constraints)
4. Already proven by existing sliding window architecture
5. Zero performance impact (DOM size unchanged)

**Next Steps:**
1. Implement Phase 1 changes (~30 minutes)
2. Test on mobile and desktop
3. Deploy and monitor
4. Consider Phase 2 enhancements based on user feedback

---
[[file:../CLAUDE.org][← Docs Map]] | [[file:../codebase-wisdom.org][← Wisdom]] | [[file:../design-architecture.org][← Architecture]]

Last Updated: 2025-10-05
