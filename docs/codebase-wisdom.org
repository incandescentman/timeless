* Mobile Safari Crash: Runaway Infinite Scroll Loads
  Date: 2025-10-04

* KBar Provider Regression: TypeError `c is not a function`
  Date: 2025-10-05

** The Bug
   After refactoring `Calendar.jsx` to add the mobile windowing logic, the command palette instantly threw `TypeError: c is not a function` in production bundles. React bubbled the exception from `CommandPalette2`.

** The Truth
   KBar’s hooks (`useKBar`) must be wrapped in `KBarProvider`. The refactor replaced the `AppContent` wrapper and accidentally dropped the provider, so KBar attempted to call an undefined hook factory (`c()` in the minified bundle).

** The Fix
   Wrap `CommandPalette`/`AppShell` in `<KBarProvider actions={kbarActions}>` inside `AppContent` (`src/App.jsx:205`). Keep `disableScrollbarManagement` to avoid conflicts with the custom layout.

** Prevention Checklist
   - [ ] Any file importing `useKBar` must live under `KBarProvider`—add a quick assertion when editing `AppContent`.
   - [ ] When refactoring layout wrappers, rerun the command palette and check bundle console for KBar errors.

** Diagnostic Tip
   If you see `TypeError: c is not a function` originating from `CommandPalette`, the provider is missing. Reintroduce it before debugging other parts of the stack.

* Month Window Infinite Scroll
  Date: 2025-10-05

** What Changed
   Calendar rendering now uses month windows (`MOBILE_CONFIG` / `DESKTOP_CONFIG` in `src/components/Calendar.jsx`). Sentinels append or prepend months while trimming the opposite edge to keep DOM size bounded.

** Architectural Notes
   - Month data is regenerated each render via `getMonthWeeks`. Profile before increasing caps; memoise by `year-month` if needed.
   - `extendMonthRange` keeps a sliding window. Don’t mutate `monthRange` outside of that helper or you risk popping the visible month.
   - Loading previous months now compensates via total document height delta (`scrollHeight` diff) mirroring the original vanilla build; if this is removed, expect the rewind bug to return.
   - Mobile and desktop caps differ (4 vs 18 months). Coordinate layout or styling changes with these limits.

** Prevention Checklist
   - [ ] Keep sentinel observers aligned with the month loader names—update both together.
   - [ ] After adjusting window sizes, scroll far in both directions to ensure months aren’t skipped or duplicated.
   - [ ] Confirm the resize effect still reinitialises the window when breakpoints change (orientation shifts, responsive layouts).

* Virtualized Month Rendering
  Date: 2025-10-05

** What Changed
   Replaced sentinel-based month loading with `VirtualizedMonthList`. Months are now rendered via translateY offsets, backed by `ResizeObserver` measurements. Scroll helpers (`scrollToDate`, `scrollToToday`) live in `CalendarContext` and drive the virtual list.
   Initial launch now passes `initialDate` (today) so the viewport starts at the correct month.

** Architectural Notes
   - Total scroll height is simulated via cumulative month heights; virtualization controls the DOM count.
   - `VirtualizedMonthList` keeps measured heights in a `Map`. Measurement updates trigger re-computation, so avoid heavy synchronous work inside `onHeightChange`.
   - Scroll commands should call `scrollToDate` (context) instead of querying DOM; this ensures the target month renders before aligning the day cell.
   - `ResizeObserver` is required for accurate heights. In legacy browsers without it, we fall back to window resize listeners—test if supporting older browsers.

** Prevention Checklist
   - [ ] When updating month markup, keep `.month-section` / `.month-header` classes intact for keyboard navigation helpers.
   - [ ] Avoid re-creating `monthsMeta` on every render; keep it memoised to prevent virtualization resets.
   - [ ] If adding variable-height content, ensure it lives inside the observed node so height updates propagate.
   - [ ] Do not re-introduce `window.scrollBy` hacks—use virtualization API instead.

** Strict Mode Double-Mount Resetting Initial Scroll
  Date: 2025-10-07

*** Symptom
   In `npm run dev` the calendar opened on January 2020 instead of today (October 2025), while production builds behaved correctly.

*** Root Cause
   React 18 Strict Mode mounts components twice in development. Our first mount scrolled to today and flipped a guard ref so the effect would never run again. The remount inherited the guard (still `true`), but measured heights restarted at zero, so the virtualiser recalculated from month index 0 and rendered the start of the range.

*** Fix
   Make the layout pass idempotent: every time it runs, compare `window.scrollY` with the computed offset for `systemToday` and snap back if they differ. This survives Strict Mode’s mount → unmount → remount cycle and keeps the context retry loop effective.

*** Prevention Checklist
   - [ ] Treat "run once" effects as best-effort; guards must reset or re-evaluate after Strict Mode remounts.
   - [ ] Keep virtualization setup idempotent—derive readiness from current measurements instead of assuming the first mount sticks.
   - [ ] Test today-centering in both dev (Strict Mode) and production after touching scroll/measurement logic.
   - [ ] Prefer invariant checks (desired offset vs actual scroll) so remounts or measurement updates auto-correct.

** Global Smooth Scroll Overrides Virtualizer
  Date: 2025-10-08

*** Symptom
   Desktop launch appeared to start at January 2020 and then animated month-by-month toward today, taking several seconds. Even after the animation finished, reflows sometimes nudged the today cell to the top edge instead of keeping it centered.

*** Root Cause
   `src/styles/mobile.css` set `scroll-behavior: smooth` on `html, body`. That global rule coerced every `window.scrollTo({ behavior: 'auto' })` call into a slow animation, including the virtualizer’s initial snap. Virtualized height measurements then retriggered an auto scroll without preserving the centered alignment, so the viewport drifted after hydration.

*** Fix
   - Removed the global smooth-scroll declaration so only explicit smooth requests animate.
   - Let `VirtualizedMonthList` honor caller-provided smooth behavior for Today/keyboard jumps while falling back to instant retries to stabilise height recalculations.
   - Tracked the initial target (month index and date) and marked the snap as done once applied, preventing subsequent measurement passes from re-running the top-aligned scroll.

*** Prevention Checklist
   - [ ] Avoid global `scroll-behavior`, scroll snapping, or momentum overrides—scope them to specific containers so virtualization keeps control.
   - [ ] When the launch viewport drifts, inspect both CSS overrides and scroll guards before tweaking effect timing.
   - [ ] Preserve caller intent: user-triggered smooth scrolls stay smooth, but initial programmatic snaps must remain `auto` to avoid replaying months.

* Overflow Days Should Be Muted, Not Removed
  Date: 2025-10-08

** Symptom
   End-of-month weeks looked duplicated because the identical seven-day row appeared again beneath the next month’s header (e.g., Oct 27 – Nov 2 showed up twice with full styling).

** Root Cause
   Month rendering is correct: both months show the bridging week so users can see adjacent days. The bug was visual—every day received the same styling, so spillover cells (e.g., Nov 1–2 inside October) were indistinguishable from in-month days.

** Fix
   Pass an `isCurrentMonth` flag to `DayCell` and apply an `outside-month` class. The CSS now mutes background, typography, and hover states for spillover cells in both light and dark themes. Weeks remain intact, but the duplicate perception disappears.

** Prevention Checklist
   - [ ] Avoid deleting overflow weeks; monthly grids rely on lead/lag days for alignment.
   - [ ] Always tag spillover cells with semantic classes (`outside-month`) so styling can differentiate them.
   - [ ] Verify light/dark theme treatments keep muted cells legible but clearly secondary.
   - [ ] When adjusting calendar colors, check month transitions to ensure the contrast signal persists.

* Virtualized Month Jumps Must Use Scroll API
  Date: 2025-10-08

** Symptom
   Jumping a full year (`P`/`N`) made the calendar “hop” month-by-month. The HUD repeated “Jumping to next year” while the viewport visibly scrolled past every intermediate month before settling.

** Root Cause
   `useMonthNavigation` traversed the DOM and called `scrollIntoView`. When the target month wasn’t mounted yet, it scrolled by 90% of the viewport and retried. Virtualization re-measured after each scroll, causing the stair-step animation until the target section finally existed.

** Fix
   Delegate to the virtualization API: call `scrollToDate(new Date(targetYear, targetMonth, 1), { behavior: 'smooth', align: 'start' })`. If the API handles the request, virtualization renders the target window immediately and performs a single smooth animation. Keep the DOM fallback only for environments where the scroll API is unavailable.

** Prevention Checklist
   - [ ] When adding navigation helpers, prefer context-provided scroll functions over manual DOM scrolling.
   - [ ] Any jump larger than a couple of months should request virtualization first, with DOM fallbacks as last resort.
   - [ ] Re-test long jumps (`±12` months, `±48` months) after virtualization changes to ensure no stair-step animations return.

* Mobile Today Button Not Centering
  Date: 2025-10-07

** Symptom
   Mobile footer "Today" button fired the HUD announcement but the viewport stayed wherever it already was.

** Root Cause
   The footer called `scrollToDate(new Date(), …)` directly. On slower devices the virtualised month list needed more than the default 32 animation frames to render today's month, so the scroll attempt timed out without ever finding the day cell.

** Fix
   Re-route all "jump to today" affordances through `CalendarContext.scrollToToday`, give it a higher retry budget, and fall back to a direct DOM query if virtualization still de-syncs.

** Prevention Checklist
   - [ ] Use `scrollToToday` (not raw DOM queries) whenever adding a new today button or shortcut.
   - [ ] Pass alignment/behaviour overrides via options instead of rebuilding the scroll logic per caller.

* Mobile View Renders Blank After Virtualisation Jump
  Date: 2025-10-07

** Symptom
   On iPhone-sized viewports the page loaded, the HUD announced "Centering on today", but the visible region was just the dot-grid background. After a long wait the calendar eventually snapped in from far off-screen.

** Root Cause
   `VirtualizedMonthList` booted with early measurements (January 2020) that were thousands of pixels tall. Because mobile hides the fixed desktop rail, the initial translate offset pushed the rendered months ~140k px above the viewport. With no scaffolding months measured yet, the estimator reused that massive height for every future month, so the layout never recovered.

** Fix
   Derive fallback heights from the average of already measured months. Once a few mobile months report their true height (~520px) the estimator stays sane and keeps the active range anchored near the viewport.

** Prevention Checklist
   - [ ] When virtualising, replace "single snapshot" estimates with rolling averages so one mis-measured month cannot skew the entire range.
   - [ ] Capture mobile screenshots after every scroll-refactor; if the grid disappears, inspect the measured heights map before touching CSS.
   - [ ] Keep Playwright or device-based smoke tests that wait for the today cell before snapshotting.

* Mobile Footer: Week Navigation vs Month Navigation
  Date: 2025-10-07

** Symptom
   Early mobile builds reused the desktop month jump, so a single tap would skip four full rows. Combined with the week-stacked layout it felt like teleporting, and the HUD copy (“Scrolling to next month”) didn’t match what the user saw.

** Fix
   Detect mobile viewports inside `MobileFooter` and route Prev / Next through `scrollWeeks(±1)`. Desktop and large tablets still use the month-based helpers so keyboard shortcuts and footer buttons stay aligned.

** Prevention Checklist
   - [ ] When touching footer controls, keep the viewport check so mobile-friendly gestures stay week-sized.
   - [ ] Update HUD copy if the action semantics change—users rely on that to confirm motion on phones.
   - [ ] If week layouts ever change height dramatically, re-evaluate the scroll amount used in `scrollWeeks`.

** The Bug
   On iOS Safari, Timeless would flash "A problem repeatedly occurred" and reload after a couple of swipes through the calendar.

** The Truth
   Mobile WebKit keeps firing `IntersectionObserver` callbacks every frame while an element stays intersecting. Our top/bottom sentinels appended ten weeks on each callback. Because the handlers captured a stale `weeks` array from their closure, every observer tick duplicated chunks, ballooning DOM nodes until Safari killed the tab for memory pressure.

   Even after debouncing the observer, we still rendered an ever-growing list of weeks. iOS Safari has far lower DOM memory limits than desktop, so scrolling a few months would still crash the tab.

** Why This Happened
   1. **No guard** – We assumed the observer would fire once per intersection; in reality it fires continuously while visible.
   2. **Stale state** – `loadPreviousWeeks`/`loadNextWeeks` read `weeks` from the render that created them, so fast callbacks re-used outdated data.
   3. **Mobile-only** – Desktop browsers throttle repeated callbacks; iOS Safari does not, so the runaway growth only happened on phones.

** The Fix
   - Added `sentinelLoadRef` flags in `src/components/Calendar.jsx:21` to ensure each sentinel triggers only once until it leaves the viewport.
   - Rebuilt the calendar around configurable week windows (mobile vs desktop) in `Calendar.jsx`. Mobile initial range is 8 weeks (lines 19-45) with a hard cap of 16 weeks (~112 cells) enforced via `extendWeekRange`.
   - Rewrote the loaders to use functional range updates (lines 83-107) so the guard stays in sync with the latest window.
   - Added a one-time scroll-to-today guard (line 53) to avoid re-centering after every range shift.
   - Removed the Eruda debugger from `index.html`—the CDN source-map 404s cluttered the console and loaded unnecessary JS on mobile.
   - Flattened mobile styles in `src/styles/mobile.css` (lines 17-130) to remove gradients and deep drop shadows that exhausted mobile GPU memory.
   - **Critical:** Clamp mobile initial render to ~56 `DayCell` components; loading the full 364-day grid on iOS Safari still exhausts memory even with guard rails.

** Prevention Checklist
   - [ ] Always debounce or guard `IntersectionObserver` handlers; expect multiple firings.
   - [ ] Prefer functional state updates inside observer callbacks to avoid stale closures.
   - [ ] Keep a hard cap on rendered weeks/days; mobile Safari dies quickly with thousands of nodes.
   - [ ] Tune the mobile window via `MOBILE_CONFIG` – default cap is 16 weeks (~112 cells); raise only with device profiling.
   - [ ] Avoid stacking box-shadows/gradients on hundreds of mobile elements—prefer flat colours.
   - [ ] Test infinite-scroll flows on mobile Safari—its scheduling differs from Chromium.
   - [ ] Watch DOM node counts (`document.getElementsByClassName('week-row').length`) during scroll; sudden spikes signal runaway loads.
   - [ ] When adjusting mobile layouts, revalidate the 56 `DayCell` budget—any increase must be justified with device profiling.

** Diagnostic Tip
   Log `weeks.length` whenever the sentinel fires. If it jumps by 10 repeatedly while you stand still, the guard is broken.

** Follow-up
   Validate on real devices and consider virtualising distant weeks if memory usage is still high after long sessions.

* The 30-Minute Header Gap: When CSS Sticky Meets Fixed Positioning
  Date: 2025-10-01

** The Bug
   The day-of-week headers in the React calendar kept overlapping with the fixed header buttons at the top. When trying to fix it, the headers would either:
   - Disappear completely behind the buttons
   - Show transparent gaps above them revealing scrolling content
   - Create new overlaps when "fixed"

** The Truth
   CSS `position: sticky` and `position: fixed` create different stacking contexts that don't play well together. The sticky element leaves a "hole" in the document flow where the background shows through. I was trying to patch this hole with increasingly complex pseudo-elements (::before, ::after) with different positioning, but each patch created new edge cases.

   **Key insight that would have saved time:**
   - `position: sticky` elements exist in normal document flow until they "stick", then create a new stacking context
   - When stuck, they leave empty space in the document flow that shows whatever background is behind
   - Pseudo-elements with different positioning contexts (absolute vs fixed vs sticky) compound the problem
   - **The answer is always a dedicated background layer**, not patching with pseudo-elements

** Why This Took 30+ Minutes
   1. **Wrong mental model**: Thought in terms of "filling gaps" instead of "creating layers"
   2. **Incremental patching**: Each fix (adjusting top, z-index, padding) seemed to work until it created a new problem
   3. **Pseudo-element rabbit hole**: Kept adding ::before/::after elements with different position values (absolute, fixed, sticky)
   4. **Not stepping back**: Instead of redesigning, kept tweaking the broken approach

** The Fix
   Created a three-layer architecture:
   #+begin_src css
   /* Layer 1: Background (z-index: 90) */
   .calendar-wrapper {
     position: fixed;
     top: 0;
     height: 140px;
     background: white;  /* Solid fill, no transparency! */
     z-index: 90;
   }

   /* Layer 2: Sticky content (z-index: 500) */
   #calendar thead {
     position: sticky;
     top: 80px;
     z-index: 500;
     background: white;  /* Must be solid */
   }

   /* Layer 3: Fixed UI (z-index: 1000) */
   #header {
     position: fixed;
     top: 0;
     z-index: 1000;
   }
   #+end_src

   **Quick diagnostic test to use next time:**
   #+begin_src css
   /* Add this temporarily to visualize the problem */
   * { background: rgba(255, 0, 0, 0.1) !important; }
   #+end_src
   This makes all transparent areas obvious - would have revealed the gap issue immediately.

** Lessons Learned / Prevention Checklist
   - [ ] **Draw the layer stack first** - Visualize z-index layers before coding
   - [ ] **Use solid background wrapper** - Don't try to patch gaps, prevent them
   - [ ] **Avoid pseudo-element gap-filling** - If you're using ::before to fill space, rethink the approach
   - [ ] **Check all color modes** - Transparent backgrounds often reveal themselves in dark mode
   - [ ] **Step back after 3 failed attempts** - If tweaking isn't working, the approach is wrong
   - [ ] **Remember the three-layer pattern** for sticky + fixed:
     1. Fixed background layer (lowest z-index) - prevents any gaps
     2. Sticky content layer (middle z-index) - your scrolling headers
     3. Fixed UI layer (highest z-index) - navigation that stays on top

* Vite CSS @import Errors: Why CSS Imports Failed in React
  Date: 2025-10-01

** The Bug
   After converting to React/Vite, got persistent console errors:
   ```
   [vite:css] @import must precede all other statements (besides @charset or empty @layer)
   ```
   Even after moving @imports to the top of the CSS file, errors persisted.

** The Truth
   Vite processes CSS imports differently than vanilla HTML. Even a single blank line or comment before @import breaks it. But more importantly, Vite actually prefers JavaScript imports over CSS @imports for better HMR (Hot Module Replacement) and bundling.

** Why This Took Multiple Attempts
   1. **First attempt**: Moved @imports to top but left blank line above them
   2. **Second attempt**: Removed blank line but kept comment above
   3. **Third attempt**: Clean @imports at top, but Vite cache held old errors
   4. **Wrong approach entirely**: Should have used JS imports from the start

** The Fix
   Import CSS files in JavaScript instead of using CSS @import:
   #+begin_src javascript
   // In main.jsx - import all CSS here
   import './styles/calendar.css';
   import './styles/day-cell.css';
   import './styles/header.css';
   import './styles/mini-calendar.css';
   import './styles/overlays.css';
   import './styles/mobile.css';
   import './styles/index.css';  // Variables last if others depend on them
   #+end_src

** Lessons Learned / Prevention Checklist
   - [ ] **Use JS imports for CSS in Vite** - Don't use CSS @import statements
   - [ ] **Clear Vite cache after CSS changes** - `rm -rf node_modules/.vite`
   - [ ] **Order matters** - Import dependencies before files that use them
   - [ ] **Check bundler docs first** - Vite/webpack handle CSS differently than vanilla HTML

* Experimental Mode Variants: Two-File System
  Date: 2025-10-03

** How It Works
   Experimental mode variants require changes in TWO places:
   1. **JavaScript config** (src/App.jsx) - Defines available variants
   2. **CSS styles** (src/styles/experimental.css) - Implements variant styling

** File 1: src/App.jsx (Lines 272-310)
   #+begin_src javascript
   const experimentalVariants = useMemo(() => [
     {
       key: 'default',              // Must match CSS selector
       label: 'Default UI',         // Shows in variant switcher
       description: 'WHAT:... | WHY:... | TO TEST:... | ASK:...'
     },
     {
       key: 'timeline-rail',        // Must match CSS selector
       label: 'Timeline Rail',
       description: 'WHAT:... | WHY:... | TO TEST:... | ASK:...'
     }
   ], []);

   const experimentalMode = useExperimentalMode({
     variants: experimentalVariants,
     defaultKey: 'default',
     experimentalDefaultKey: 'timeline-rail'  // First variant shown in experimental mode
   });
   #+end_src

** File 2: src/styles/experimental.css
   #+begin_src css
   /* key from App.jsx becomes CSS selector */
   [data-experimental-variant="timeline-rail"] .calendar-grid {
     /* variant-specific styles */
   }
   #+end_src

** Step-by-Step: Adding a New Variant
   1. **Add variant config to src/App.jsx** (inside experimentalVariants array)
      - Set unique `key` (becomes CSS selector)
      - Set display `label` (shown in UI)
      - Write `description` using WHAT/WHY/TO TEST/ASK format

   2. **Add variant styles to src/styles/experimental.css**
      - Use `[data-experimental-variant="your-key"]` as selector prefix
      - Target specific elements: `.calendar-grid`, `.day-cell`, `.week-row`, etc.

   3. **Test without cache**
      - Kill dev server
      - Run: `rm -rf node_modules/.vite`
      - Restart: `npm run dev`
      - Hard refresh browser (Cmd+Shift+R)

** Step-by-Step: Removing Variants
   1. **Remove from src/App.jsx** - Delete variant object from experimentalVariants array
   2. **Remove from src/styles/experimental.css** - Delete all CSS rules for that variant
   3. **Clear cache and restart** (same as adding)

** Finding Old Variants in Git
   #+begin_src bash
   # Find commits with variant changes
   git log --all --oneline | grep -i "variant\|rail\|ledger"

   # View variant config from specific commit
   git show COMMIT_HASH:src/styles/experimental.css

   # Extract specific variant section
   git show COMMIT_HASH:src/styles/experimental.css | sed -n '/VARIANT NAME/,/^\/\* ====.*===== \*\//p'
   #+end_src

** Common Mistakes
   - [ ] **Only updating CSS** - Variant won't appear in switcher without App.jsx entry
   - [ ] **Only updating App.jsx** - Variant will appear but have no styling
   - [ ] **Key mismatch** - CSS selector must exactly match the `key` in App.jsx
   - [ ] **Browser cache** - Always hard refresh after variant changes
   - [ ] **Dev server cache** - Clear node_modules/.vite if changes don't appear

* Mini Calendar Disappearing: Position Sticky vs Fixed in Infinite Scroll
  Date: 2025-10-03

** The Bug
   Mini calendar kept disappearing after 20+ CSS fixes. It would:
   - Show briefly on page load
   - Disappear when calendar auto-scrolled to today
   - Sometimes reappear when scrolling up
   - Different behavior at different viewport widths

** The Truth (Why It Took So Many Attempts)
   Multiple compounding issues masked the real problem:

   1. **Structural Issue**: Calendar rail (containing mini calendar) was rendered INSIDE the scrolling grid as the first column, not as a separate fixed element

   2. **Position Sticky Trap**: `position: sticky` stays with its container. When the infinite scroll calendar scrolled to today, the sticky rail scrolled with it off-screen

   3. **Hidden Overflow Masked Problem**: `overflow-x: hidden` on html/body prevented horizontal scroll but also hid that the calendar was actually overflowing

   4. **Media Query Hidden**: At viewport ≤900px, a media query set `display: none` on the entire rail

   5. **Compound Padding**: Multiple containers (.app-shell + #calendarContainer + .calendar-layout) each added padding, pushing content off-screen

** Why Each Fix Failed
   - **Attempt 1-5**: Adjusted padding/margins - didn't address structural issue
   - **Attempt 6-8**: Changed sticky positioning - still inside scrolling container
   - **Attempt 9-11**: Modified z-index - positioning was the issue, not stacking
   - **Attempt 12**: Set calc() height - resulted in negative values on small screens
   - **Attempt 13-15**: Changed grid columns - rail still scrolled with content

** The Fix That Worked
   #+begin_src css
   /* 1. Make rail position fixed, outside document flow */
   .calendar-rail {
     position: fixed !important;
     top: 1.5rem;
     left: 1.5rem;
     z-index: 9999;
   }

   /* 2. Adjust calendar layout to account for fixed rail */
   .calendar-layout {
     display: grid;
     grid-template-columns: 1fr;  /* Single column since rail is fixed */
     margin-left: 280px;  /* Make room for fixed rail */
     width: calc(100% - 280px);
   }
   #+end_src

** Diagnostic Process That Would Have Saved Time
   1. **Check if element exists in DOM**: DevTools → Elements → Search "calendar-rail"
   2. **Check computed position**: DevTools → Computed → position property
   3. **Temporarily remove ALL overflow hidden**: Set overflow:visible on all parents
   4. **Add bright background colors**: `background: red !important` to see where element actually is
   5. **Check ALL media queries**: Search for `display: none` in all CSS files
   6. **Log component rendering**: Add console.log to verify component mounts

** Lessons Learned / Prevention Checklist
   - [ ] **Fixed sidebars need fixed positioning** - Not sticky when content scrolls infinitely
   - [ ] **Check component hierarchy first** - CSS can't fix structural React issues
   - [ ] **Remove overflow:hidden when debugging** - It masks the real problem
   - [ ] **Search for display:none in media queries** - Common cause of disappearing elements
   - [ ] **Use DevTools computed styles** - Shows cumulative effect of all CSS
   - [ ] **Position fixed elements at root level** - Don't nest inside scrolling containers
   - [ ] **Test at multiple viewport widths** - Media queries can hide elements
   - [ ] **Hard refresh after CSS changes** - Browser cache can show old styles

** Quick Fix Pattern for Fixed Sidebars
   #+begin_src css
   /* Sidebar */
   .sidebar {
     position: fixed;
     top: 0;
     left: 0;
     width: 280px;
     height: 100vh;
     z-index: 1000;
   }

   /* Main content */
   .main-content {
     margin-left: 280px;  /* Same as sidebar width */
     width: calc(100% - 280px);
   }
   #+end_src

* React Overlay Not Visible: Always Use Portal for Fixed Overlays
  Date: 2025-10-04

** The Bug
   Help overlay (?key shortcut) was triggering (state changed, component rendered) but nothing was visible on screen. Spent 10+ attempts debugging event handlers when the real issue was CSS rendering context.

** The Truth
   When an overlay with `position: fixed` doesn't appear but the component is rendering:
   - Parent containers with `transform`, `perspective`, `filter`, or `will-change` create new stacking contexts
   - These break `position: fixed` - the overlay renders relative to the transformed parent, not the viewport
   - The overlay might be rendering at scroll position 0 in an infinite scroll container (off-screen)

** Why This Took 10+ Attempts (Wrong debugging path)
   1. **Attempt 1-3**: Assumed keyboard shortcut conflict with KBar command palette
   2. **Attempt 4-5**: Reordered event handlers, added capture phase listeners
   3. **Attempt 6-8**: Added excessive console.log debugging to trace event flow
   4. **Attempt 9**: Modified z-index thinking it was a stacking issue
   5. **Attempt 10**: Finally used React Portal - the obvious solution

   **The symptoms told the whole story**: State toggling ✓, Component rendering ✓, Nothing visible ✗ = CSS stacking context issue

** The Fix
   #+begin_src jsx
   import { createPortal } from 'react-dom';

   function HelpOverlay({ onClose }) {
     return createPortal(
       <div id="help" className="overlay" onClick={onClose}>
         {/* overlay content */}
       </div>,
       document.body  // Render directly to body, bypass all parent CSS
     );
   }
   #+end_src

** Diagnostic Steps (Should have done first)
   1. Check if component renders: Add console.log in component
   2. Check if state changes: Log state in parent
   3. If both yes but not visible → **IMMEDIATELY use Portal**
   4. Don't waste time on event handlers if state is working

** Lessons Learned / Prevention Checklist
   - [ ] **Overlay not visible but state working = Use Portal immediately**
   - [ ] **Don't debug event handlers when state changes correctly**
   - [ ] **Portal is the standard solution for overlays/modals/tooltips**
   - [ ] **CSS stacking contexts break position:fixed - Portal bypasses them all**
   - [ ] **Symptoms matter**: State ✓ + Rendering ✓ + Not visible ✗ = CSS issue, not JS

** Quick Pattern for Any Overlay/Modal
   #+begin_src jsx
   // Always use this pattern for overlays
   import { createPortal } from 'react-dom';

   function AnyOverlay({ show, onClose, children }) {
     if (!show) return null;

     return createPortal(
       <div className="overlay" onClick={onClose}>
         <div onClick={e => e.stopPropagation()}>
           {children}
         </div>
       </div>,
       document.body
     );
   }
   #+end_src

** CRITICAL UPDATE: Portal + Inline Styles Required
   Date: 2025-10-04 (Updated after breaking it again)

   **The Double Fix**: After fixing the overlay with Portal + inline styles, I broke it again by removing the inline styles thinking they were just for debugging. WRONG!

   **Why Both Are Needed**:
   - Portal renders to `document.body`, outside the React component tree
   - CSS classes may not be available in that context or have specificity issues
   - Inline styles guarantee the styles are applied regardless of DOM location
   - **Inline styles are PART OF THE FIX, not debugging code**

   **The Pattern That Actually Works**:
   #+begin_src jsx
   return createPortal(
     <div
       id="help"
       className="overlay"  // Keep for semantic purposes
       onClick={onClose}
       style={{
         position: 'fixed',
         top: 0,
         left: 0,
         right: 0,
         bottom: 0,
         backgroundColor: 'rgba(0, 0, 0, 0.7)',
         display: 'flex',
         alignItems: 'center',
         justifyContent: 'center',
         zIndex: 99999
       }}>
       {/* content */}
     </div>,
     document.body
   );
   #+end_src

* LLM Anti-Patterns in This Codebase

This section documents mistakes AI assistants commonly make when working on this specific codebase.

** Pattern: Breaking Today Cell Highlighting                      :ui:HIGH_SEVERITY:2025-10:
Problem: LLM modifies Calendar.tsx styling or refactors cell rendering without preserving isToday logic
Fix: Always check Calendar.tsx for existing today highlighting (text-red-600 or #ef4444) before changing cell styles
Prevention: Load visual-design-philosophy.org before any UI changes; search for "isToday" before modifying Calendar.tsx
Frequency: High - LLMs often "clean up" or "improve" styling without realizing today highlighting is sacred

** Pattern: Adding CSS Transitions/Animations                     :ui:HIGH_SEVERITY:2025-10:
Problem: LLM adds `transition:`, `animation:`, or transform effects despite "no animations" being a core principle
Fix: Remove all transitions, animations, and transform effects immediately
Prevention: Check the-timeless-approach.org and visual-design-philosophy.org before adding any interactive effects
Frequency: Very High - LLMs default to adding smooth transitions for "better UX"

** Pattern: Changing Event Data Structure Without Backward Compatibility :data:HIGH_SEVERITY:2025-10:
Problem: LLM modifies Event interface in types/index.ts, making existing fields optional or changing required fields
Fix: Always maintain existing required fields; new fields must be optional
Prevention: Check design-architecture.org::*Backward-Compatible Data Structure before modifying Event interface
Frequency: Medium - Usually happens when adding features like categories or tags

** Pattern: Using Arbitrary Color Values                          :ui:MEDIUM_SEVERITY:2025-10:
Problem: LLM uses custom colors like `text-[#FF5733]` or `bg-blue-500` instead of approved gray scale
Fix: Use only Tailwind's gray scale (gray-50 through gray-900) and text-red-600 for today only
Prevention: Load visual-design-philosophy.org before any styling work; check color decision tree
Frequency: Medium - LLMs like to add "helpful" color coding

** Pattern: Mutating State Directly                               :react:MEDIUM_SEVERITY:2025-10:
Problem: LLM uses `events.push()` or `events[i] = ...` instead of immutable updates
Fix: Always use spread operators or array methods that return new arrays
Prevention: Review design-architecture.org::*State Must Be Immutable; look for `setEvents([...events, newEvent])` pattern
Frequency: Low - Modern LLMs usually get this right, but still happens

** Pattern: Partial Context Submissions                           :process:HIGH_SEVERITY:2025-10:
Problem: LLM submits code changes without loading full file context or related documentation
Fix: Always load the *entire* file and related sections (design-architecture.org, codebase-wisdom.org, visual-design-philosophy.org) before submitting
Prevention: Follow pre-session ritual in CLAUDE.org; enforce context-loading checklist
Frequency: Very High - Common in multi-file or cross-cutting changes

** Pattern: Inventing New Utility Functions                       :code-org:LOW_SEVERITY:2025-10:
Problem: LLM creates new date formatting or utility functions without checking if they already exist
Fix: Search existing codebase (especially utils/dateUtils.ts) before creating new utilities
Prevention: Load utils/dateUtils.ts before implementing date-related features
Frequency: Low - Usually only happens with date manipulation

* Viewport Navigation: getBoundingClientRect vs offsetTop for Scrolling
  Date: 2025-10-04

** The Bug
   Implementing keyboard shortcuts (n/p) to navigate between months. The navigation would:
   - Always jump to January 2025 when pressing 'n' (instead of next month)
   - Jump to November 2024 when pressing 'p' (instead of previous month)
   - Console showed it always detected currentMonthIndex as 0 regardless of scroll position

** The Truth
   **offsetTop vs getBoundingClientRect - They measure different things!**
   - `offsetTop`: Distance from top of DOCUMENT (never changes as you scroll)
   - `getBoundingClientRect().top`: Distance from top of VIEWPORT (changes as you scroll)
   - `window.scrollY`: Current scroll position from top of document

   The original code was comparing `offsetTop` (document-relative) with `scrollY + offset` (also document-relative), but the math was wrong. It would always find index 0 because the first month header always had the smallest offsetTop.

** Why This Took 4+ Attempts
   1. **Attempt 1**: Moved jumpMonths function inside component (fixed scope issue, but not the bug)
   2. **Attempt 2**: Tried fixing with offsetTop math - wrong approach entirely
   3. **Attempt 3**: Overcomplicated with manual scroll calculations instead of scrollIntoView
   4. **Attempt 4**: Finally used getBoundingClientRect() for viewport-relative positions

   **Time wasted**: Added extensive console.log debugging for keyboard triggers when the real issue was position calculation

** The Fix That Actually Works
   #+begin_src javascript
   const jumpMonths = (direction) => {
     const monthHeaders = Array.from(document.querySelectorAll('.month-header'));

     // Get viewport-relative positions
     let currentMonthIndex = -1;
     monthHeaders.forEach((header, i) => {
       const rect = header.getBoundingClientRect();
       // Is this header visible in viewport?
       if (rect.top < window.innerHeight && rect.bottom > 0) {
         // Find the one closest to top of viewport
         if (rect.top >= 0 && currentMonthIndex === -1) {
           currentMonthIndex = i;
         }
       }
     });

     // Navigate to target month
     const targetIndex = currentMonthIndex + direction;
     if (targetIndex >= 0 && targetIndex < monthHeaders.length) {
       monthHeaders[targetIndex].scrollIntoView({
         behavior: 'smooth',
         block: 'start'
       });
     }
   };
   #+end_src

** Diagnostic Pattern for Viewport Navigation
   #+begin_src javascript
   // Quick debug to see what's visible
   document.querySelectorAll('.month-header').forEach(h => {
     const rect = h.getBoundingClientRect();
     console.log({
       month: h.textContent,
       viewportTop: rect.top,        // Negative = above viewport
       viewportBottom: rect.bottom,  // > window.innerHeight = below viewport
       visible: rect.top < window.innerHeight && rect.bottom > 0
     });
   });
   #+end_src

** Lessons Learned / Prevention Checklist
   - [ ] **For viewport visibility: ALWAYS use getBoundingClientRect()**
   - [ ] **For document position: Use offsetTop**
   - [ ] **Don't mix the two** - They measure from different origins
   - [ ] **scrollIntoView() is usually better** than calculating scroll positions manually
   - [ ] **Test the detection first** - Log what element is detected before trying to navigate
   - [ ] **Viewport-relative checks**:
     - Visible: `rect.top < window.innerHeight && rect.bottom > 0`
     - Above viewport: `rect.bottom < 0`
     - Below viewport: `rect.top > window.innerHeight`
     - At top: `rect.top >= 0 && rect.top < 100`

** Quick Reference: Position Properties
   | Property | Measures From | Changes on Scroll | Use Case |
   |----------|--------------|--------------------|----------|
   | offsetTop | Document top | No | Total distance from page top |
   | getBoundingClientRect().top | Viewport top | Yes | Is element visible? |
   | scrollY | Document top | Yes | Current scroll position |
   | clientY (events) | Viewport top | No | Mouse/touch position |
   | pageY (events) | Document top | No | Mouse/touch absolute position |

** The Pattern: Finding Currently Visible Element
   #+begin_src javascript
   function getCurrentVisibleElement(selector) {
     const elements = Array.from(document.querySelectorAll(selector));

     for (const el of elements) {
       const rect = el.getBoundingClientRect();
       // Element is at top of viewport (adjust threshold as needed)
       if (rect.top >= 0 && rect.top < 150) {
         return el;
       }
     }

     // Fallback: find first visible element
     return elements.find(el => {
       const rect = el.getBoundingClientRect();
       return rect.top < window.innerHeight && rect.bottom > 0;
     });
   }
   #+end_src

* Command Feedback HUD: Terminator-Style Machine Perception UI
  Date: 2025-10-04
  Last Updated: 2025-10-04

** What It Is
   A sci-fi themed heads-up display that provides visual feedback for keyboard commands and user actions.

** Display Sections
   1. **Meta section** (top):
      - Date (e.g., "Fri, Oct 4")
      - Time (12-hour format with AM/PM)
      - Events Today (count from calendarData)
   2. **Core section** (center):
      - Tag: "Command"
      - Command label with chromatic aberration effect
      - Blinking cursor (▌)
      - Optional description (if provided)

** Experimental Mode Variants
   Two variants available via Option-X toggle:

   ***Default Terminator HUD:***
   - Clean cyan palette
   - Basic scanlines and crosshair
   - Minimal effects

   ***Enhanced Terminator HUD*** (src/styles/experimental.css):
   - Corner brackets - L-shaped cyan brackets at all 8 corners
   - Chromatic aberration - RGB split on title text (red left, cyan right)
   - Edge glow pulse - Subtle traveling light around border (4.5s animation)
   - Animated data stream - Scrolling hex values in background
   - Static/noise texture - Flickering grid overlay
   - Hexagonal accents - Pulsing hex shapes in corners

** User Interactions
   - **ESC key**: Immediately dismisses HUD (bypasses exit animation)
   - **Auto-dismiss**: HUD fades out after EXIT_ANIMATION_MS (280ms)

** Commands That Trigger HUD
   Navigation:
   - `n`/`p`/`[`/`]` - Month navigation (shows "Jumping forward/back X months")
   - `N`/`P` - Year navigation (shows "Jumping forward/back 1 year")
   - `t` - "Centering on today"
   - `y` - "Opening year view"

   UI Toggles:
   - `Cmd/Ctrl+K` or `/` - "Opening command palette"
   - `?` - "Showing keyboard shortcuts"
   - `Cmd/Ctrl+D` - "Toggling dark mode"
   - `m` - "Entering/Exiting multi-select"

   Editing:
   - `c` or `T` - "Opening today composer"
   - `Cmd/Ctrl+Z` - "Undoing last action"
   - `Cmd/Ctrl+Shift+Z` or `Cmd/Ctrl+Y` - "Redoing action"

   Mobile:
   - Mobile footer buttons also trigger HUD

** Commands That Don't Trigger HUD
   (These provide immediate visual feedback through scrolling/focus)
   - `i` - Enter keyboard navigation mode
   - `q`/`Escape` - Exit keyboard navigation mode
   - `h`/`j`/`k`/`l`/Arrow keys - Navigate days in keyboard mode
   - `Enter` - Open composer on focused day
   - `Backspace` - Delete notes from focused day
   - `Alt+ArrowUp/Down` - Alternative month navigation

** Implementation Details
   Files:
   - src/components/CommandFeedback.jsx
   - src/styles/command-feedback.css
   - src/styles/experimental.css (enhanced variant)
   - src/contexts/CommandFeedbackContext.jsx

   Key patterns:
   - Uses `useCalendar()` hook to access calendarData for event counts
   - Uses `date-fns` format() for date/time formatting
   - Portal rendering to document.body for z-index independence
   - Keyboard event listener for ESC dismissal
   - requestAnimationFrame for smooth entrance animation

** Tone Variants (unused currently)
   - `--positive`: Green-tinted borders
   - `--warning`: Amber-tinted borders and text
   - `--neutral`: Default cyan

** Performance Considerations
   - requestAnimationFrame prevents jank
   - EXIT_ANIMATION_MS ensures cleanup timing
   - Portal rendering avoids nested re-renders
   - Event listeners properly cleaned up in useEffect returns

* Vim Navigation Keys Hijacking Browser Shortcuts
  Date: 2025-10-04

** The Bug
   Vim-style navigation keys (h/j/k/l) in keyboard focus mode were hijacking browser shortcuts like Cmd+L (focus address bar).

** The Problem
   In src/hooks/useKeyboardShortcuts.js, the keyboard navigation code checked for vim keys without excluding modifier key combinations:
   #+begin_src javascript
   // WRONG - hijacks Cmd+L
   if (e.key === 'ArrowLeft' || e.key === 'h') {
     e.preventDefault();
     // ...
   }
   #+end_src

** The Fix
   Add modifier key checks to all vim navigation keys:
   #+begin_src javascript
   // CORRECT - allows Cmd+L to work
   if (e.key === 'ArrowLeft' || (e.key === 'h' && !e.metaKey && !e.ctrlKey)) {
     e.preventDefault();
     // ...
   }
   #+end_src

   Applied to all vim keys: h (left), j (down), k (up), l (right)

** Lessons Learned
   - [ ] **Always exclude modifier keys from vim-style bindings** - Browser/OS shortcuts take precedence
   - [ ] **Test keyboard shortcuts with modifiers** - Cmd+K, Cmd+L, Cmd+H, etc.
   - [ ] **Pattern for vim keys**: `(e.key === 'x' && !e.metaKey && !e.ctrlKey && !e.altKey)`
   - [ ] **Don't preventDefault on system shortcuts** - Let browser handle Cmd/Ctrl combinations

* Mobile Swipe Gestures: Use Established Library Over Custom Touch Handlers
  Date: 2025-10-11

** The Bug
   Custom touch handlers for swipe-to-delete/edit had zero visual feedback. Events would suddenly vanish when swiping right with no indication of what was happening—the event just disappeared "without a trace."

** The Problem
   The original implementation in `DayEventRow` (src/components/DayCell.jsx:12-191) used raw touch event handlers:
   - `handleTouchStart` / `handleTouchMove` / `handleTouchEnd` tracking deltaX/deltaY
   - Hard-coded thresholds (`SWIPE_DELETE_THRESHOLD = 80px`)
   - Immediately deleted or opened editor when threshold crossed
   - No progressive visual feedback during the swipe
   - No background color reveal
   - No slide-with-finger animation
   - Event would just vanish, creating a jarring UX

** Why Custom Touch Handlers Failed
   1. **No visual feedback loop**: Touch handlers only checked final position, didn't update UI during gesture
   2. **Instant action**: Crossing threshold immediately fired `onDelete()` with no animation
   3. **Missing animation library knowledge**: Would need to manually implement transform, transition timing, background reveal
   4. **Maintenance burden**: Custom gesture code is fragile and hard to debug across devices
   5. **Reinventing the wheel**: Standard swipe-to-action UX already solved by existing libraries

** The Fix
   Replaced custom touch handlers with `@sandstreamdev/react-swipeable-list` library:

   #+begin_src javascript
   import {
     SwipeableListItem,
     ActionAnimations
   } from '@sandstreamdev/react-swipeable-list';

   // Swipe right → Delete with red background
   <SwipeableListItem
     swipeRight={{
       content: (
         <div style={{
           backgroundColor: '#ef4444',  // Red background
           color: 'white',
           paddingRight: '16px',
           // ... flex centering
         }}>
           Delete
         </div>
       ),
       action: () => onDelete(index),
       actionAnimation: ActionAnimations.REMOVE  // Smooth remove animation
     }}
     swipeLeft={{
       content: (
         <div style={{
           backgroundColor: '#3b82f6',  // Blue background
           color: 'white',
           // ...
         }}>
           Edit
         </div>
       ),
       action: () => onStartEdit(index)
     }}
     threshold={0.3}  // 30% swipe triggers action
   >
     {eventContent}
   </SwipeableListItem>
   #+end_src

** What the Library Provides (That Custom Handlers Didn't)
   - **Progressive visual feedback**: Background and action text revealed as you swipe
   - **Follows your finger**: Event content slides with touch position in real-time
   - **Smooth animations**: Built-in `ActionAnimations.REMOVE` for delete
   - **Threshold configuration**: Easy to tune sensitivity (`threshold={0.3}`)
   - **Cross-browser/device tested**: Handles edge cases (multi-touch, scroll conflicts)
   - **onSwipeProgress callback**: Could add progress-based effects if needed

** Lessons Learned / Prevention Checklist
   - [ ] **Use established UI libraries for standard gestures** - Don't reinvent swipe-to-delete/edit
   - [ ] **Visual feedback is not optional** - Users need to see the action before it happens
   - [ ] **Research existing solutions first** - `react-swipeable-list`, `framer-motion`, etc.
   - [ ] **Custom touch handlers only when truly custom** - E.g., novel gesture interactions
   - [ ] **Test gesture UX on real devices** - Touch simulators don't reveal feedback issues
   - [ ] **Check if library already installed** - Project already had `react-swipeable` (unused)

** Popular React Swipe Libraries (For Future Reference)
   - **@sandstreamdev/react-swipeable-list** - Full-featured, built-in action animations (chosen)
   - **react-swipeable** - Lower-level, just gesture detection (already installed but not right fit)
   - **framer-motion** - General animation library with drag support (already installed, overkill for this)
   - **react-swipe-to-delete-component** - Simpler but less maintained

** Quick Pattern for Swipeable List Items
   #+begin_src javascript
   // Install: npm install @sandstreamdev/react-swipeable-list
   import { SwipeableListItem, ActionAnimations } from '@sandstreamdev/react-swipeable-list';
   import '@sandstreamdev/react-swipeable-list/dist/styles.css';

   <SwipeableListItem
     swipeRight={{
       content: <ActionBackground label="Delete" color="red" />,
       action: handleDelete,
       actionAnimation: ActionAnimations.REMOVE
     }}
     swipeLeft={{
       content: <ActionBackground label="Edit" color="blue" />,
       action: handleEdit
     }}
     threshold={0.3}
   >
     <YourContent />
   </SwipeableListItem>
   #+end_src
