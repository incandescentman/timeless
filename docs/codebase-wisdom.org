* The 30-Minute Header Gap: When CSS Sticky Meets Fixed Positioning
  Date: 2025-10-01

** The Bug
   The day-of-week headers in the React calendar kept overlapping with the fixed header buttons at the top. When trying to fix it, the headers would either:
   - Disappear completely behind the buttons
   - Show transparent gaps above them revealing scrolling content
   - Create new overlaps when "fixed"

** The Truth
   CSS `position: sticky` and `position: fixed` create different stacking contexts that don't play well together. The sticky element leaves a "hole" in the document flow where the background shows through. I was trying to patch this hole with increasingly complex pseudo-elements (::before, ::after) with different positioning, but each patch created new edge cases.

   **Key insight that would have saved time:**
   - `position: sticky` elements exist in normal document flow until they "stick", then create a new stacking context
   - When stuck, they leave empty space in the document flow that shows whatever background is behind
   - Pseudo-elements with different positioning contexts (absolute vs fixed vs sticky) compound the problem
   - **The answer is always a dedicated background layer**, not patching with pseudo-elements

** Why This Took 30+ Minutes
   1. **Wrong mental model**: Thought in terms of "filling gaps" instead of "creating layers"
   2. **Incremental patching**: Each fix (adjusting top, z-index, padding) seemed to work until it created a new problem
   3. **Pseudo-element rabbit hole**: Kept adding ::before/::after elements with different position values (absolute, fixed, sticky)
   4. **Not stepping back**: Instead of redesigning, kept tweaking the broken approach

** The Fix
   Created a three-layer architecture:
   #+begin_src css
   /* Layer 1: Background (z-index: 90) */
   .calendar-wrapper {
     position: fixed;
     top: 0;
     height: 140px;
     background: white;  /* Solid fill, no transparency! */
     z-index: 90;
   }

   /* Layer 2: Sticky content (z-index: 500) */
   #calendar thead {
     position: sticky;
     top: 80px;
     z-index: 500;
     background: white;  /* Must be solid */
   }

   /* Layer 3: Fixed UI (z-index: 1000) */
   #header {
     position: fixed;
     top: 0;
     z-index: 1000;
   }
   #+end_src

   **Quick diagnostic test to use next time:**
   #+begin_src css
   /* Add this temporarily to visualize the problem */
   * { background: rgba(255, 0, 0, 0.1) !important; }
   #+end_src
   This makes all transparent areas obvious - would have revealed the gap issue immediately.

** Lessons Learned / Prevention Checklist
   - [ ] **Draw the layer stack first** - Visualize z-index layers before coding
   - [ ] **Use solid background wrapper** - Don't try to patch gaps, prevent them
   - [ ] **Avoid pseudo-element gap-filling** - If you're using ::before to fill space, rethink the approach
   - [ ] **Check all color modes** - Transparent backgrounds often reveal themselves in dark mode
   - [ ] **Step back after 3 failed attempts** - If tweaking isn't working, the approach is wrong
   - [ ] **Remember the three-layer pattern** for sticky + fixed:
     1. Fixed background layer (lowest z-index) - prevents any gaps
     2. Sticky content layer (middle z-index) - your scrolling headers
     3. Fixed UI layer (highest z-index) - navigation that stays on top

* Vite CSS @import Errors: Why CSS Imports Failed in React
  Date: 2025-10-01

** The Bug
   After converting to React/Vite, got persistent console errors:
   ```
   [vite:css] @import must precede all other statements (besides @charset or empty @layer)
   ```
   Even after moving @imports to the top of the CSS file, errors persisted.

** The Truth
   Vite processes CSS imports differently than vanilla HTML. Even a single blank line or comment before @import breaks it. But more importantly, Vite actually prefers JavaScript imports over CSS @imports for better HMR (Hot Module Replacement) and bundling.

** Why This Took Multiple Attempts
   1. **First attempt**: Moved @imports to top but left blank line above them
   2. **Second attempt**: Removed blank line but kept comment above
   3. **Third attempt**: Clean @imports at top, but Vite cache held old errors
   4. **Wrong approach entirely**: Should have used JS imports from the start

** The Fix
   Import CSS files in JavaScript instead of using CSS @import:
   #+begin_src javascript
   // In main.jsx - import all CSS here
   import './styles/calendar.css';
   import './styles/day-cell.css';
   import './styles/header.css';
   import './styles/mini-calendar.css';
   import './styles/overlays.css';
   import './styles/mobile.css';
   import './styles/index.css';  // Variables last if others depend on them
   #+end_src

** Lessons Learned / Prevention Checklist
   - [ ] **Use JS imports for CSS in Vite** - Don't use CSS @import statements
   - [ ] **Clear Vite cache after CSS changes** - `rm -rf node_modules/.vite`
   - [ ] **Order matters** - Import dependencies before files that use them
   - [ ] **Check bundler docs first** - Vite/webpack handle CSS differently than vanilla HTML

* Experimental Mode Variants: Two-File System
  Date: 2025-10-03

** How It Works
   Experimental mode variants require changes in TWO places:
   1. **JavaScript config** (src/App.jsx) - Defines available variants
   2. **CSS styles** (src/styles/experimental.css) - Implements variant styling

** File 1: src/App.jsx (Lines 272-310)
   #+begin_src javascript
   const experimentalVariants = useMemo(() => [
     {
       key: 'default',              // Must match CSS selector
       label: 'Default UI',         // Shows in variant switcher
       description: 'WHAT:... | WHY:... | TO TEST:... | ASK:...'
     },
     {
       key: 'timeline-rail',        // Must match CSS selector
       label: 'Timeline Rail',
       description: 'WHAT:... | WHY:... | TO TEST:... | ASK:...'
     }
   ], []);

   const experimentalMode = useExperimentalMode({
     variants: experimentalVariants,
     defaultKey: 'default',
     experimentalDefaultKey: 'timeline-rail'  // First variant shown in experimental mode
   });
   #+end_src

** File 2: src/styles/experimental.css
   #+begin_src css
   /* key from App.jsx becomes CSS selector */
   [data-experimental-variant="timeline-rail"] .calendar-grid {
     /* variant-specific styles */
   }
   #+end_src

** Step-by-Step: Adding a New Variant
   1. **Add variant config to src/App.jsx** (inside experimentalVariants array)
      - Set unique `key` (becomes CSS selector)
      - Set display `label` (shown in UI)
      - Write `description` using WHAT/WHY/TO TEST/ASK format

   2. **Add variant styles to src/styles/experimental.css**
      - Use `[data-experimental-variant="your-key"]` as selector prefix
      - Target specific elements: `.calendar-grid`, `.day-cell`, `.week-row`, etc.

   3. **Test without cache**
      - Kill dev server
      - Run: `rm -rf node_modules/.vite`
      - Restart: `npm run dev`
      - Hard refresh browser (Cmd+Shift+R)

** Step-by-Step: Removing Variants
   1. **Remove from src/App.jsx** - Delete variant object from experimentalVariants array
   2. **Remove from src/styles/experimental.css** - Delete all CSS rules for that variant
   3. **Clear cache and restart** (same as adding)

** Finding Old Variants in Git
   #+begin_src bash
   # Find commits with variant changes
   git log --all --oneline | grep -i "variant\|rail\|ledger"

   # View variant config from specific commit
   git show COMMIT_HASH:src/styles/experimental.css

   # Extract specific variant section
   git show COMMIT_HASH:src/styles/experimental.css | sed -n '/VARIANT NAME/,/^\/\* ====.*===== \*\//p'
   #+end_src

** Common Mistakes
   - [ ] **Only updating CSS** - Variant won't appear in switcher without App.jsx entry
   - [ ] **Only updating App.jsx** - Variant will appear but have no styling
   - [ ] **Key mismatch** - CSS selector must exactly match the `key` in App.jsx
   - [ ] **Browser cache** - Always hard refresh after variant changes
   - [ ] **Dev server cache** - Clear node_modules/.vite if changes don't appear

* Mini Calendar Disappearing: Position Sticky vs Fixed in Infinite Scroll
  Date: 2025-10-03

** The Bug
   Mini calendar kept disappearing after 20+ CSS fixes. It would:
   - Show briefly on page load
   - Disappear when calendar auto-scrolled to today
   - Sometimes reappear when scrolling up
   - Different behavior at different viewport widths

** The Truth (Why It Took So Many Attempts)
   Multiple compounding issues masked the real problem:

   1. **Structural Issue**: Calendar rail (containing mini calendar) was rendered INSIDE the scrolling grid as the first column, not as a separate fixed element

   2. **Position Sticky Trap**: `position: sticky` stays with its container. When the infinite scroll calendar scrolled to today, the sticky rail scrolled with it off-screen

   3. **Hidden Overflow Masked Problem**: `overflow-x: hidden` on html/body prevented horizontal scroll but also hid that the calendar was actually overflowing

   4. **Media Query Hidden**: At viewport â‰¤900px, a media query set `display: none` on the entire rail

   5. **Compound Padding**: Multiple containers (.app-shell + #calendarContainer + .calendar-layout) each added padding, pushing content off-screen

** Why Each Fix Failed
   - **Attempt 1-5**: Adjusted padding/margins - didn't address structural issue
   - **Attempt 6-8**: Changed sticky positioning - still inside scrolling container
   - **Attempt 9-11**: Modified z-index - positioning was the issue, not stacking
   - **Attempt 12**: Set calc() height - resulted in negative values on small screens
   - **Attempt 13-15**: Changed grid columns - rail still scrolled with content

** The Fix That Worked
   #+begin_src css
   /* 1. Make rail position fixed, outside document flow */
   .calendar-rail {
     position: fixed !important;
     top: 1.5rem;
     left: 1.5rem;
     z-index: 9999;
   }

   /* 2. Adjust calendar layout to account for fixed rail */
   .calendar-layout {
     display: grid;
     grid-template-columns: 1fr;  /* Single column since rail is fixed */
     margin-left: 280px;  /* Make room for fixed rail */
     width: calc(100% - 280px);
   }
   #+end_src

** Diagnostic Process That Would Have Saved Time
   1. **Check if element exists in DOM**: DevTools â†’ Elements â†’ Search "calendar-rail"
   2. **Check computed position**: DevTools â†’ Computed â†’ position property
   3. **Temporarily remove ALL overflow hidden**: Set overflow:visible on all parents
   4. **Add bright background colors**: `background: red !important` to see where element actually is
   5. **Check ALL media queries**: Search for `display: none` in all CSS files
   6. **Log component rendering**: Add console.log to verify component mounts

** Lessons Learned / Prevention Checklist
   - [ ] **Fixed sidebars need fixed positioning** - Not sticky when content scrolls infinitely
   - [ ] **Check component hierarchy first** - CSS can't fix structural React issues
   - [ ] **Remove overflow:hidden when debugging** - It masks the real problem
   - [ ] **Search for display:none in media queries** - Common cause of disappearing elements
   - [ ] **Use DevTools computed styles** - Shows cumulative effect of all CSS
   - [ ] **Position fixed elements at root level** - Don't nest inside scrolling containers
   - [ ] **Test at multiple viewport widths** - Media queries can hide elements
   - [ ] **Hard refresh after CSS changes** - Browser cache can show old styles

** Quick Fix Pattern for Fixed Sidebars
   #+begin_src css
   /* Sidebar */
   .sidebar {
     position: fixed;
     top: 0;
     left: 0;
     width: 280px;
     height: 100vh;
     z-index: 1000;
   }

   /* Main content */
   .main-content {
     margin-left: 280px;  /* Same as sidebar width */
     width: calc(100% - 280px);
   }
   #+end_src

* React Overlay Not Visible: Always Use Portal for Fixed Overlays
  Date: 2025-10-04

** The Bug
   Help overlay (?key shortcut) was triggering (state changed, component rendered) but nothing was visible on screen. Spent 10+ attempts debugging event handlers when the real issue was CSS rendering context.

** The Truth
   When an overlay with `position: fixed` doesn't appear but the component is rendering:
   - Parent containers with `transform`, `perspective`, `filter`, or `will-change` create new stacking contexts
   - These break `position: fixed` - the overlay renders relative to the transformed parent, not the viewport
   - The overlay might be rendering at scroll position 0 in an infinite scroll container (off-screen)

** Why This Took 10+ Attempts (Wrong debugging path)
   1. **Attempt 1-3**: Assumed keyboard shortcut conflict with KBar command palette
   2. **Attempt 4-5**: Reordered event handlers, added capture phase listeners
   3. **Attempt 6-8**: Added excessive console.log debugging to trace event flow
   4. **Attempt 9**: Modified z-index thinking it was a stacking issue
   5. **Attempt 10**: Finally used React Portal - the obvious solution

   **The symptoms told the whole story**: State toggling âœ“, Component rendering âœ“, Nothing visible âœ— = CSS stacking context issue

** The Fix
   #+begin_src jsx
   import { createPortal } from 'react-dom';

   function HelpOverlay({ onClose }) {
     return createPortal(
       <div id="help" className="overlay" onClick={onClose}>
         {/* overlay content */}
       </div>,
       document.body  // Render directly to body, bypass all parent CSS
     );
   }
   #+end_src

** Diagnostic Steps (Should have done first)
   1. Check if component renders: Add console.log in component
   2. Check if state changes: Log state in parent
   3. If both yes but not visible â†’ **IMMEDIATELY use Portal**
   4. Don't waste time on event handlers if state is working

** Lessons Learned / Prevention Checklist
   - [ ] **Overlay not visible but state working = Use Portal immediately**
   - [ ] **Don't debug event handlers when state changes correctly**
   - [ ] **Portal is the standard solution for overlays/modals/tooltips**
   - [ ] **CSS stacking contexts break position:fixed - Portal bypasses them all**
   - [ ] **Symptoms matter**: State âœ“ + Rendering âœ“ + Not visible âœ— = CSS issue, not JS

** Quick Pattern for Any Overlay/Modal
   #+begin_src jsx
   // Always use this pattern for overlays
   import { createPortal } from 'react-dom';

   function AnyOverlay({ show, onClose, children }) {
     if (!show) return null;

     return createPortal(
       <div className="overlay" onClick={onClose}>
         <div onClick={e => e.stopPropagation()}>
           {children}
         </div>
       </div>,
       document.body
     );
   }
   #+end_src

** CRITICAL UPDATE: Portal + Inline Styles Required
   Date: 2025-10-04 (Updated after breaking it again)

   **The Double Fix**: After fixing the overlay with Portal + inline styles, I broke it again by removing the inline styles thinking they were just for debugging. WRONG!

   **Why Both Are Needed**:
   - Portal renders to `document.body`, outside the React component tree
   - CSS classes may not be available in that context or have specificity issues
   - Inline styles guarantee the styles are applied regardless of DOM location
   - **Inline styles are PART OF THE FIX, not debugging code**

   **The Pattern That Actually Works**:
   #+begin_src jsx
   return createPortal(
     <div
       id="help"
       className="overlay"  // Keep for semantic purposes
       onClick={onClose}
       style={{
         position: 'fixed',
         top: 0,
         left: 0,
         right: 0,
         bottom: 0,
         backgroundColor: 'rgba(0, 0, 0, 0.7)',
         display: 'flex',
         alignItems: 'center',
         justifyContent: 'center',
         zIndex: 99999
       }}>
       {/* content */}
     </div>,
     document.body
   );
   #+end_src

* Viewport Navigation: getBoundingClientRect vs offsetTop for Scrolling
  Date: 2025-10-04

** The Bug
   Implementing keyboard shortcuts (n/p) to navigate between months. The navigation would:
   - Always jump to January 2025 when pressing 'n' (instead of next month)
   - Jump to November 2024 when pressing 'p' (instead of previous month)
   - Console showed it always detected currentMonthIndex as 0 regardless of scroll position

** The Truth
   **offsetTop vs getBoundingClientRect - They measure different things!**
   - `offsetTop`: Distance from top of DOCUMENT (never changes as you scroll)
   - `getBoundingClientRect().top`: Distance from top of VIEWPORT (changes as you scroll)
   - `window.scrollY`: Current scroll position from top of document

   The original code was comparing `offsetTop` (document-relative) with `scrollY + offset` (also document-relative), but the math was wrong. It would always find index 0 because the first month header always had the smallest offsetTop.

** Why This Took 4+ Attempts
   1. **Attempt 1**: Moved jumpMonths function inside component (fixed scope issue, but not the bug)
   2. **Attempt 2**: Tried fixing with offsetTop math - wrong approach entirely
   3. **Attempt 3**: Overcomplicated with manual scroll calculations instead of scrollIntoView
   4. **Attempt 4**: Finally used getBoundingClientRect() for viewport-relative positions

   **Time wasted**: Added extensive console.log debugging for keyboard triggers when the real issue was position calculation

** The Fix That Actually Works
   #+begin_src javascript
   const jumpMonths = (direction) => {
     const monthHeaders = Array.from(document.querySelectorAll('.month-header'));

     // Get viewport-relative positions
     let currentMonthIndex = -1;
     monthHeaders.forEach((header, i) => {
       const rect = header.getBoundingClientRect();
       // Is this header visible in viewport?
       if (rect.top < window.innerHeight && rect.bottom > 0) {
         // Find the one closest to top of viewport
         if (rect.top >= 0 && currentMonthIndex === -1) {
           currentMonthIndex = i;
         }
       }
     });

     // Navigate to target month
     const targetIndex = currentMonthIndex + direction;
     if (targetIndex >= 0 && targetIndex < monthHeaders.length) {
       monthHeaders[targetIndex].scrollIntoView({
         behavior: 'smooth',
         block: 'start'
       });
     }
   };
   #+end_src

** Diagnostic Pattern for Viewport Navigation
   #+begin_src javascript
   // Quick debug to see what's visible
   document.querySelectorAll('.month-header').forEach(h => {
     const rect = h.getBoundingClientRect();
     console.log({
       month: h.textContent,
       viewportTop: rect.top,        // Negative = above viewport
       viewportBottom: rect.bottom,  // > window.innerHeight = below viewport
       visible: rect.top < window.innerHeight && rect.bottom > 0
     });
   });
   #+end_src

** Lessons Learned / Prevention Checklist
   - [ ] **For viewport visibility: ALWAYS use getBoundingClientRect()**
   - [ ] **For document position: Use offsetTop**
   - [ ] **Don't mix the two** - They measure from different origins
   - [ ] **scrollIntoView() is usually better** than calculating scroll positions manually
   - [ ] **Test the detection first** - Log what element is detected before trying to navigate
   - [ ] **Viewport-relative checks**:
     - Visible: `rect.top < window.innerHeight && rect.bottom > 0`
     - Above viewport: `rect.bottom < 0`
     - Below viewport: `rect.top > window.innerHeight`
     - At top: `rect.top >= 0 && rect.top < 100`

** Quick Reference: Position Properties
   | Property | Measures From | Changes on Scroll | Use Case |
   |----------|--------------|--------------------|----------|
   | offsetTop | Document top | No | Total distance from page top |
   | getBoundingClientRect().top | Viewport top | Yes | Is element visible? |
   | scrollY | Document top | Yes | Current scroll position |
   | clientY (events) | Viewport top | No | Mouse/touch position |
   | pageY (events) | Document top | No | Mouse/touch absolute position |

** The Pattern: Finding Currently Visible Element
   #+begin_src javascript
   function getCurrentVisibleElement(selector) {
     const elements = Array.from(document.querySelectorAll(selector));

     for (const el of elements) {
       const rect = el.getBoundingClientRect();
       // Element is at top of viewport (adjust threshold as needed)
       if (rect.top >= 0 && rect.top < 150) {
         return el;
       }
     }

     // Fallback: find first visible element
     return elements.find(el => {
       const rect = el.getBoundingClientRect();
       return rect.top < window.innerHeight && rect.bottom > 0;
     });
   }
   #+end_src
