#+TITLE: Design Architecture - Timeless Calendar
#+DATE: 2025-10-12
#+TAGS: architecture, technical, design
#+KEYWORDS: react, typescript, tailwind, state-management

#+BEGIN_COMMENT
LLM_CONTEXT:
- Purpose: System architecture, mental models, and design decisions
- Key Docs: TL;DR, integration points, ADR links
- Always read before: Designing or refactoring architecture
#+END_COMMENT

* TL;DR
- This system handles: Year-view calendar with local event storage and minimal UI
- Core components: App.tsx (state), Calendar.jsx + VirtualizedMonthList.jsx (virtualized month grid), EventCard.tsx, EventForm.tsx
- Mental model: Think of it as a single-page app with immutable state transformations - no external state library, just React useState
- Key gotchas: Event data must stay backward-compatible; today cell highlighting is sacred; no animations allowed
- Last major update: 2025-10-05

* For LLM Context
Summarize this file if loaded into a coding model:
- This document defines the technical architecture of the Timeless calendar application
- Key invariants: Backward-compatible event structure, ISO dates (YYYY-MM-DD), immutable state, no animations
- When to update: When adding major features, changing architecture patterns, or integrating new systems
- Where this connects to code:
  - Event state management: [[file:../src/App.tsx][App.tsx]]
  - Year grid rendering: [[file:../src/components/Calendar.tsx][Calendar.tsx]]
  - Event data types: [[file:../src/types/index.ts][types/index.ts]]
  - Date utilities: [[file:../src/utils/dateUtils.ts][dateUtils.ts]]

* Overview

Timeless is a year-view calendar application built with React and TypeScript. The architecture prioritizes simplicity, local-first data storage, and a timeless design aesthetic (no animations, minimal UI).

** Mental Model

Think of the application as:
- A **pure function** from (events array + selected month) → rendered year view
- State transformations are **immutable** - we never mutate the events array directly
- The **year grid** is the primary interface - all 12 months visible simultaneously
- **Today's cell** is always highlighted in red - this is non-negotiable
- Rendering uses a **virtualized month list** so scroll stays smooth regardless of how far back/forward the user travels

* Core Design Principles

** 1. Single Source of Truth (Local State)

All event data lives in React state (useState in App.tsx). No external state management library (Redux, Zustand, etc.).

State shape:
#+begin_src typescript
const [events, setEvents] = useState<Event[]>([]);
const [selectedMonth, setSelectedMonth] = useState<number>(new Date().getMonth());
#+end_src

Dependencies: events array → EventCard components → Calendar grid

** 2. Year View as Primary Interface

Unlike traditional calendars that show one month, Timeless displays all 12 months in a grid layout. This forces year-scale thinking.

Layout: 4 columns × 3 rows (on desktop)

Each month contains a traditional 7-column day grid.

** 3. Backward-Compatible Data Structure

Event data evolved from simple strings to rich objects while maintaining full backward compatibility.

Current event format (stored in CalendarContext):
#+begin_src javascript
// Events are stored as arrays keyed by dateId (M_D_YYYY format)
calendarData = {
  "9_15_2025": [
    {
      text: "Event text",      // Required - event content
      completed: false,         // Required - completion status (boolean)
      tags: []                  // Required - array of tag strings
    }
  ]
}
#+end_src

Legacy string events are automatically normalized on load:
#+begin_src javascript
// Legacy format (still supported)
"9_15_2025": ["Simple string event"]

// Automatically normalizes to:
"9_15_2025": [{ text: "Simple string event", completed: false, tags: [] }]
#+end_src

Event utilities ([[file:../src/utils/eventUtils.js][eventUtils.js]]):
- normalizeEvent() - Converts string or object to standard format
- getEventText() - Extracts text from string or object
- isEventCompleted() - Safely checks completion status
- toggleEventCompletion() - Returns new event with toggled completion
- setEventTags() - Returns new event with updated tags

Storage layer ([[file:../src/utils/storage.js][storage.js]]) automatically normalizes on load/import and exports with metadata.

** 4. ISO Date Format (YYYY-MM-DD)

All dates use ISO 8601 format for consistency and parseability.

Example: "2025-10-04"

Utilities: See [[file:../src/utils/dateUtils.ts][dateUtils.ts]] for date manipulation helpers

** 5. No Animations Constraint

Zero CSS transitions or animations. This is a strict design invariant enforced by the timeless aesthetic.

Violations must be rejected in code review.

See: [[file:visual-design-philosophy.org::*No Animations Rule][visual-design-philosophy.org::*No Animations Rule]]

* Component Architecture

** State Management (App.tsx)

App.tsx owns all state and passes props down to children.

State:
- events: Event[]
- selectedMonth: number
- (future: selectedYear, filters, etc.)

Key functions:
- addEvent(event: Event)
- updateEvent(id: string, updates: Partial<Event>)
- deleteEvent(id: string)

All mutations return new arrays (immutable updates).

** Year Grid Rendering (Calendar.jsx)

Calendar.jsx orchestrates the UI shell (header, swipe handlers, keyboard shortcuts) and delegates month rendering to a virtualized list.

Critical logic: isToday highlighting
#+begin_src typescript
const isToday = (date: Date) => {
  const today = new Date();
  return date.getDate() === today.getDate() &&
         date.getMonth() === today.getMonth() &&
         date.getFullYear() === today.getFullYear();
};
#+end_src

** Virtualized Month Rendering (VirtualizedMonthList.jsx)

- Precomputes month metadata (2020–2035 by default) with estimated heights.
- Uses translateY + absolute positioning to simulate full scroll height while only mounting visible months.
- `ResizeObserver` refines measured heights so scroll offsets stay accurate as content grows.
- Falls back to the *average* of measured heights whenever a month lacks its own measurement. This prevents a single outlier month (e.g., during initial boot) from pushing subsequent months off-screen on mobile.
- Any in-flight `scrollToDate` attempt re-runs automatically after fresh measurements arrive so “jump to today” doesn’t land above or below the viewport while the list settles.
- Exposes `scrollToMonthIndex` / `scrollToDate` for commands (`t`, `g`, mobile today button, etc.).
- Keeps DOM bounded (mobile ≈4 months, desktop ≈18 months) regardless of date range; the user can scroll years in either direction without height-delta hacks.

** Mobile Navigation Bar (MobileFooter.jsx)

- Shows Today / Prev / Next / Menu buttons below 768px viewports.
- Today delegates to `CalendarContext.scrollToToday`, which retries until the target day renders and then recenters.
- Prev/Next move *one week* on mobile to match the week-stacked layout; desktop continues to jump by months using the shared month-navigation helpers.
- Buttons announce their action through the command feedback HUD to mirror keyboard shortcuts.
- On mobile, an inline month header is injected immediately before the first-of-month cell so the label scrolls with day one while the desktop header stays hidden.

** Mobile Event Composer (MobileEventComposer.jsx)

- Below 768px viewports, tapping an empty day opens a centered overlay instead of the inline composer.
- The overlay portals to `document.body`, locks background scrolling, and autofocuses the input once mounted.
- Desktop still renders the inline composer inside `DayCell`; both flows call the same add/update handlers.
- Mobile keeps the ripple affordance on tap but the overlay now auto-commits when non-empty input loses focus (outside tap/Escape) and simply closes if empty—no explicit buttons rendered.
- Input focus is requested on the first frame after mount so Mobile Safari raises the keyboard immediately (mirroring Canonical's Minimalist capture modal).
- The footer hint mirrors the Minimalist capture treatment (checkmark + "Tap anywhere to save") while staying within Timeless color tokens.
- Blank-day layout clamps to a shallower min-height/padding on mobile so empty rows compress while note-bearing cells retain breathing room.
- Day headers collapse into a single row on mobile: weekday stays left-aligned, month + day are right-justified, and all abbreviations come from `dateUtils.daysOfWeek` / `dateUtils.shortMonths` so wording stays consistent across the app.

** Mobile Event Gestures

Mobile event rows support three gesture interactions optimized for task/todo workflows:

*** Swipe Right → Toggle Completion
- Reveals **green checkmark** background with "Done" or "Undone" label
- Progressive green gradient intensity (rgba(34, 197, 94)) as swipe extends
- Triggers `toggleEventCompletionStatus()` when swipe exceeds 100px threshold
- Instant toggle on release, no animation
- Visual feedback: completed events show strikethrough + reduced opacity

*** Long Press → Delete
- **500ms press threshold** triggers red overlay with trash icon
- Full-screen red background (rgba(239, 68, 68, 0.95)) with "Delete" label
- Cancels automatically if finger moves >10px in any direction
- Triggers slide-out delete animation on release
- Shows undo toast for 4-second recovery window

*** Swipe Left → Tag Management
- Reveals **blue/gray tags icon** with "Tags" label
- Progressive slate gradient intensity (rgba(100, 116, 139))
- Triggers tag manager when swipe exceeds 50px threshold
- Currently shows placeholder toast (UI deferred to future session)

*** Implementation Details
- Uses `react-swipeable` library with direct transform control
- Touch handlers (onTouchStart/Move/End) for long press detection
- SwipeableEventRow component wraps mobile event rows (<768px)
- Desktop uses non-swipeable DayEventRow with click-to-edit
- Progressive color intensity provides clear visual feedback during swipe
- Smooth transitions (0.18s cubic-bezier) when resetting position
- Calendar-level swipe navigation guarded to ignore gestures originating from `[data-event-row]`
- Hardware acceleration via translateX for smooth performance
- All gesture thresholds tuned to prevent accidental triggers

** Command Feedback HUD & Keystroke Overlay

- `CommandFeedbackProvider` renders the desktop HUD; actions send `{ label, description }` so the title and destination (e.g., "December 2025") appear on separate lines.
- `KeystrokeFeedbackProvider` drives the right-edge keystroke overlay, showing a large monospace glyph for ~0.4 s after each shortcut on desktop (suppressed on mobile).
- `useKeyboardShortcuts` formats chords (⌘, Shift, Alt, letter keys) and emits both the keystroke pulse and the semantic HUD event, keeping visual and textual feedback in sync.
- Month navigation now resolves through `scrollToDate` before announcing, which ensures the HUD always references the accurate destination month/year.

** Event Display (EventCard.tsx)

Displays individual event within a calendar cell.

Props:
- event: Event
- onEdit: () => void
- onDelete: () => void

Styling: Minimal card with hover state, no animations

** Event Creation/Editing (EventForm.tsx)

Modal form for adding/editing events.

Fields:
- Title (required)
- Date (pre-filled from clicked cell)
- Description (optional)

Validation:
- Title must not be empty
- Date must be valid ISO format

* Data Flow and Storage

** Event Lifecycle

1. User clicks "Add Event" → EventForm opens
2. User fills form → Form validates input
3. User submits → App.tsx.addEvent() called
4. New event added to events array (immutably)
5. State update triggers re-render
6. Calendar.tsx re-renders → EventCard displays new event

** Local Storage (Future)

Events will be persisted to localStorage for durability.

Key: "timeless-events"
Format: JSON.stringify(events)

Load on mount, save on every mutation.

* State Management Approach

** Why No External Library?

- App is simple enough for useState
- Reduces bundle size
- No learning curve for contributors
- Direct, predictable state flow

** When to Consider External State Management

If we add:
- Complex filtering/search
- Undo/redo functionality
- Multi-user sync
- Complex derived state

Then consider Zustand or Context + useReducer.

* Integration Points

** Date Utilities (utils/dateUtils.ts)

Helper functions for date manipulation:
- formatDate(date: Date): string
- parseDate(dateStr: string): Date
- isToday(date: Date): boolean
- getMonthDays(year: number, month: number): Date[]

All use ISO format internally.

** Type Definitions (types/index.ts)

Central type definitions:
- Event interface
- (Future: Filter, ViewMode, etc.)

Exported for use across components.

* Recent Updates

- 2025-10-12: Documented new event object structure with completion status and tags
- 2025-10-12: Documented new gesture meanings (swipe right = done, long press = delete, swipe left = tags)
- 2025-10-12: Updated Mobile Event Gestures section with task/todo workflow optimizations
- 2025-10-08: Added mobile single-row day headers with canonical weekday/month abbreviations
- 2025-10-08: Documented mobile composer overlay and tightened mobile spacing
- 2025-10-04: Initial architecture documentation created
- 2025-10-04: Established TL;DR and LLM Context sections
- 2025-10-04: Documented year view layout and state management approach

* Key Gotchas

** 1. Today Cell Highlighting Must Persist

When adding new styles or refactoring Calendar.tsx, ensure isToday logic remains intact.

Anti-pattern: [[file:CLAUDE.org::*Pattern: Breaking Today Cell Highlighting][CLAUDE.org::*Pattern: Breaking Today Cell Highlighting]]

** 2. Event Data Backward Compatibility

Never change required fields or remove existing fields from Event interface.

Anti-pattern: [[file:CLAUDE.org::*Pattern: Changing Event Data Structure][CLAUDE.org::*Pattern: Changing Event Data Structure]]

** 3. No Animations Enforcement

LLMs often add CSS transitions. These must be removed immediately.

Anti-pattern: [[file:CLAUDE.org::*Pattern: Adding Animations][CLAUDE.org::*Pattern: Adding Animations]]

** 4. State Must Be Immutable

Never mutate events array directly:

Bad:
#+begin_src typescript
events.push(newEvent); // ❌ Mutation!
setEvents(events);
#+end_src

Good:
#+begin_src typescript
setEvents([...events, newEvent]); // ✓ Immutable
#+end_src

* Future Considerations

** Potential Improvements

1. **Event Search/Filter**: Add search bar and category filters
2. **Recurring Events**: Support simple recurrence patterns
3. **Data Export**: CSV or iCal export
4. **Keyboard Navigation**: Arrow keys, shortcuts
5. **Local Storage Persistence**: Save events to localStorage

** Scaling Considerations

1. If events array grows large (1000+ events), consider:
   - Indexing by date for faster lookups
   - Virtual scrolling for event lists
   - Lazy loading events by month

2. If adding multi-user features:
   - Switch to external state management
   - Add conflict resolution
   - Implement sync protocol

* How to Change Safely

** When Modifying Calendar Layout

1. Read [[file:visual-design-philosophy.org][visual-design-philosophy.org]] first
2. Preserve today cell highlighting
3. Test across different months (some have 28 days, some 31)
4. Verify responsive design on mobile

** When Adding Event Fields

1. Make new fields optional
2. Update Event interface in types/index.ts
3. Update EventForm to handle new field
4. Update EventCard to display new field (if needed)
5. Test with existing events (backward compatibility)

** When Refactoring State

1. Ensure all mutations remain immutable
2. Update prop types throughout component tree
3. Test event creation, editing, deletion flows
4. Verify no performance regressions

* Testing Strategy

** Key Test Cases

1. **Event CRUD**: Create, read, update, delete events
2. **Today Highlighting**: Verify today's cell is red
3. **Date Handling**: Test edge cases (leap years, month boundaries)
4. **Backward Compatibility**: Load old event data, verify it still works
5. **Responsive Layout**: Test on mobile and desktop viewports

** Visual Regression

- Screenshot calendar on 1st of month
- Screenshot calendar on 31st of month
- Screenshot today's cell highlighting
- Screenshot event cards

---
[[file:CLAUDE.org][← Docs Map]] | [[file:the-timeless-approach.org][← Philosophy]] | [[file:visual-design-philosophy.org][← Design]] | [[file:codebase-wisdom.org][→ Wisdom]]

Last Updated: 2025-10-12
