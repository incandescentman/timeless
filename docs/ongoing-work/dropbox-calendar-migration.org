#+TITLE: Dropbox-Backed Calendar Sync Plan
#+CREATED: <2024-10-01 Tue>

* Context
The production Timeless calendar currently persists shared state to Redis via =api/calendar.js=, while local single-user flows rely on =localStorage=. We want parity with Canonical's minimalist capture flow by storing the shared Markdown diary in a Dropbox-synced file. This diary must stay writable in local dev, and Vercel deployments must read/write it via Dropbox's content API.

* Goals
- Replace Redis as the canonical data store without regressing multi-device sync.
- Keep the browser experience identical (still use =localStorage= for offline resilience).
- Allow localhost development to edit the Dropbox-backed Markdown diary directly, avoiding round-tripping through hosted APIs.
- Maintain timestamp-based conflict resolution so concurrent edits reconcile cleanly.

* Proposed Architecture
** Data File (Markdown Diary)
- Canonical file: =/Users/jay/Dropbox/github/timeless/jay-diary.md= (already produced by “Export Markdown Diary”).
- Repo alias: symlink from =data/jay-diary.md= to the Dropbox path so the dev server can read/write it.
- Format: year/month/day headings with bullet lists, exactly as emitted by =exportAsMarkdownDiary()= in =src/utils/storage.js= (include tags and completion markers).
- Timestamp metadata: store =lastSavedTimestamp= in a trailing comment block (e.g. =<!-- lastSavedTimestamp: 1727822222000 -->=) so the client keeps conflict detection while leaving the Markdown human-readable.

** Local Development Writes
- Add a Vite middleware (e.g. =/__update-calendar-diary=) mirroring Canonical's =/__update-org-file=.
- Middleware accepts ={ path, content }=, resolves against repo root, overwrites the Markdown symlink target, logs activity.
- Client defaults to this endpoint when =VITE_CALENDAR_SYNC_ENDPOINT= is undefined; =fetchServerCalendar()= should read =VITE_CALENDAR_LOAD_ENDPOINT= to pull fresh Markdown during dev.

** Production Writes (Vercel)
- Two new serverless handlers:
  - =api/calendar-save.ts=: accepts POST Markdown payload (or structured JSON converted server-side), injects/updates the timestamp comment, uploads to Dropbox (mode =overwrite=) at =DROPBOX_CALENDAR_PATH=.
  - =api/calendar-load.ts=: downloads the Markdown file from Dropbox and returns ={ content }=.
- Token management: reuse the refresh-token helper from Canonical's minimalist functions; allow =DROPBOX_ACCESS_TOKEN= short-circuit for local debugging.
- Environment: =DROPBOX_APP_KEY=, =DROPBOX_APP_SECRET=, =DROPBOX_REFRESH_TOKEN=, =DROPBOX_CALENDAR_PATH= (e.g. =/Apps/Timeless/calendar/jay-diary.md=).

** Client Configuration Changes
- Update =src/utils/storage.js=:
  - Read =VITE_CALENDAR_SYNC_ENDPOINT= / =VITE_CALENDAR_LOAD_ENDPOINT=, fallback to current =API_ENDPOINT= only when both absent.
  - Introduce Markdown ↔ calendar-data parser pair: one to render =calendarData= into Markdown (leveraging =exportAsMarkdownDiary()= with timestamp injection), one to parse Markdown back into the calendar object (reverse of export).
  - After successful save, if a load endpoint exists, hydrate from the remote Markdown so tag order and formatting stay canonical (mirrors Canonical's =ensureRemoteHydration=).
- Adjust =CalendarContext= to call the new parser helpers instead of assuming JSON; ensure we only hit Dropbox endpoints when env vars exist.

* Implementation Plan
** Preparation
- [ ] Create =data/jay-diary.md= symlink pointing at the Dropbox canonical file.
- [ ] Export current Redis snapshot, convert to Markdown diary (reuse =exportAsMarkdownDiary()=) and write it into the Dropbox file to seed initial state.
- [ ] Document Dropbox env vars and Markdown format expectations in =README.org= / deployment runbook.

** Local Dev Middleware
- [ ] Add middleware in =vite.config.js= for =/__update-calendar-diary=, mirroring the org-writer helper.
- [ ] Update dev-only client defaults to POST to that path with ={ path: 'data/jay-diary.md', content }= payloads (content is Markdown string).
- [ ] Add lightweight logging (console) for visibility when writes happen.

** Client Refactor
- [ ] Extend =src/utils/storage.js= to detect custom sync/load endpoints via Vite env vars.
- [ ] Build =formatCalendarAsMarkdown(calendarData, timestamp)= using existing export helper (add timestamp comment support).
- [ ] Build =parseMarkdownDiary(rawMarkdown)= to reconstruct =calendarData= + timestamp (handle headings, completion markers, tags).
- [ ] Surface =VITE_CALENDAR_LOAD_ENDPOINT= to =fetchServerCalendar()= and =CalendarContext= hydration logic; ensure we only hit Dropbox when the env var exists.
- [ ] Preserve timestamp conflict logic; confirm we still bail early when server timestamp is older than local.
- [ ] Add optional dev helper to pull in =import.meta.glob('/data/jay-diary.md', { as: 'raw' })= so local bootstrapping remains instant.

** Serverless Dropbox Bridge
- [ ] Add =api/calendar-save.ts= and =api/calendar-load.ts= (TypeScript) modeled on Canonical's minimalist endpoints with shared token cache logic.
- [ ] Factor token helper into =lib/dropbox.ts= (optional) if reuse is desired across repos).
- [ ] Update =vercel.json= rewrites so =/api/calendar= still points somewhere sensible (GET hits load handler, POST hits save handler) or adjust client to hit the new explicit routes.
- [ ] Write Vitest unit tests for token helper edge cases if feasible (optional but good safety net).

** QA & Cutover
- [ ] In dev, simulate multiple browser tabs to verify timestamp sync and race conditions.
- [ ] Deploy preview, verify Dropbox writes succeed and file updates propagate back.
- [ ] Remove Redis dependency (package + env var references) only after Dropbox path confirmed stable for at least one day.
- [ ] Update docs and MCP configuration references if they rely on Redis.

* Open Questions
- Should we keep Redis as optional fallback (env-guarded) for disaster recovery?
- Do we need to keep =api/calendar.js= around temporarily for backward compatibility with mobile clients?
- Where should we store additional metadata (e.g. tags list) in the Markdown file without making it unreadable?
- Can we share Dropbox helper utilities via a common package across Canonical and Timeless to avoid duplication?
